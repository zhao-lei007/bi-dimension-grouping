<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è‡ªå®šä¹‰åˆ†ç»„é¡µé¢ - æ™ºèƒ½åˆ†ç»„ç‰ˆ</title>
    <style>
        /* Global Styles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            background-color: #f0f2f5;
            margin: 0;
            padding: 20px;
            color: #333;
        }

        .modal-container {
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-width: 1600px;
            margin: auto;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        .modal-header {
            padding: 16px 24px;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header .title { font-size: 16px; font-weight: 500; }
        .modal-header .guide-link { font-size: 14px; color: #1890ff; text-decoration: none; cursor: pointer; }
        .modal-header .guide-link:hover { color: #40a9ff; }

        /* Main Content */
        .modal-content { display: flex; border-bottom: 1px solid #f0f0f0; }
        .panel { padding: 24px; box-sizing: border-box; }
        .left-panel { width: 21.34%; border-right: 1px solid #f0f0f0; }
        .middle-panel { width: 32.00%; border-right: 1px solid #f0f0f0; }
        .right-panel { width: 46.66%; }
        .panel-header { font-size: 14px; margin-bottom: 16px; }
        .panel-header-title { font-weight: 500; color: #555; }

        .action-bar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
        .button-group { display: flex; gap: 8px; }
        .search-input { position: relative; width: 36%; }
        .search-input input { width: 100%; padding: 8px 12px 8px 30px; border: 1px solid #d9d9d9; border-radius: 4px; transition: all 0.3s; box-sizing: border-box; }
        .search-input input:focus { border-color: #40a9ff; outline: none; box-shadow: 0 0 0 2px rgba(24, 144, 255, 0.2); }
        .search-input .icon { position: absolute; left: 10px; top: 50%; transform: translateY(-50%); color: #aaa; }

        .btn { padding: 6px 15px; border-radius: 4px; border: 1px solid transparent; font-size: 13px; cursor: pointer; transition: all 0.3s; }
        .btn-primary { background-color: #1890ff; color: #fff; border-color: #1890ff; }
        .btn-primary:hover { background-color: #40a9ff; border-color: #40a9ff; }
        .btn-success { background-color: #52c41a; color: #fff; border-color: #52c41a; }
        .btn-success:hover { background-color: #73d13d; border-color: #73d13d; }
        .btn-default { background-color: #fff; color: #333; border-color: #d9d9d9; }
        .btn-default:hover { color: #40a9ff; border-color: #40a9ff; }
        .btn-sm { padding: 4px 10px; font-size: 11px; }

        /* Icon button styles */
        .btn-icon {
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid #d9d9d9;
            background-color: #fff;
            color: #666;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 32px;
            height: 32px;
        }
        .btn-icon:hover {
            background-color: #f0f8ff;
            border-color: #40a9ff;
            color: #1890ff;
            transform: scale(1.05);
        }
        .btn-icon:active {
            transform: scale(0.95);
        }

        /* Priority adjustment button styles */
        .priority-btn-group {
            display: inline-flex;
            gap: 2px;
            margin-right: 8px;
        }

        .btn-priority {
            padding: 4px 6px;
            border-radius: 3px;
            border: 1px solid #d9d9d9;
            background-color: #fff;
            color: #666;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 24px;
            height: 24px;
        }

        .btn-priority:hover:not(:disabled) {
            background-color: #f0f8ff;
            border-color: #40a9ff;
            color: #1890ff;
            transform: scale(1.05);
        }

        .btn-priority:active:not(:disabled) {
            transform: scale(0.95);
        }

        .btn-priority:disabled {
            background-color: #f5f5f5;
            border-color: #e8e8e8;
            color: #bbb;
            cursor: not-allowed;
            transform: none;
        }

        .data-table { border: 1px solid #f0f0f0; border-radius: 4px; }
        .table-header, .table-row { display: flex; align-items: center; padding: 12px 16px; font-size: 14px; }
        .table-header { background-color: #fafafa; font-weight: 500; }
        .table-body { height: 380px; overflow-y: auto; }
        .table-row { border-bottom: 1px solid #f0f0f0; }
        .table-row:last-child { border-bottom: none; }
        .table-row:hover { background-color: #e6f7ff; }
        
        .col-checkbox { flex: 0 0 40px; }
        .col-name { flex: 1; }
        .col-group { flex: 0 0 100px; color: #888; text-align: right; }
        .col-op { flex: 0 0 120px; text-align: right; }
        .col-delete { flex: 0 0 40px; text-align: center; }

        .pagination { display: flex; justify-content: flex-end; align-items: center; margin-top: 16px; font-size: 14px; }
        .pagination span { margin: 0 8px; }
        .pagination-btn { padding: 4px 8px; border: 1px solid #d9d9d9; background: #fff; cursor: pointer; border-radius: 4px; }
        .pagination-btn:disabled { color: #ccc; cursor: not-allowed; }

        /* Footer */
        .modal-footer { padding: 16px 24px; display: flex; justify-content: space-between; align-items: center; }
        .footer-left .checkbox-label { font-size: 14px; display: flex; align-items: center; }
        .footer-left input { margin-right: 8px; }
        .footer-right .btn { margin-left: 8px; }
        
        /* Utility & Right Panel Specific */
        .text-blue { color: #1890ff; cursor: pointer; }
        .text-blue:hover { color: #40a9ff; }
        .group-list-container, .rule-list-container { height: 420px; overflow-y: auto; border: 1px solid #f0f0f0; border-radius: 4px; }
        .group-table { height: 100%; display: flex; flex-direction: column; }
        .group-table .table-header { background-color: #fafafa; font-weight: 500; border-bottom: 1px solid #f0f0f0; }
        .group-table .table-body { flex: 1; overflow-y: auto; }
        .group-table .col-checkbox { flex: 0 0 40px; }
        .group-table .col-group-name { flex: 1; }
        .group-table .col-operation { flex: 0 0 140px; text-align: right; }
        .group-table .group-name { font-weight: 500; margin-right: 8px; }
        .group-table .group-count { color: #888; font-size: 12px; }
        .group-table .col-operation .btn { margin-left: 4px; }

        /* Auto badge styles */
        .group-table .auto-badge {
            display: inline-block;
            background-color: #52c41a;
            color: white;
            font-size: 10px;
            font-weight: normal;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 6px;
            cursor: help;
            position: relative;
        }

        /* Tooltip styles */
        .tooltip {
            position: absolute;
            background-color: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .tooltip.show {
            opacity: 1;
        }

        .tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }

        /* Rule table styles */
        .rule-table { height: 100%; display: flex; flex-direction: column; overflow: hidden; }
        .rule-table-scroll-container { flex: 1; overflow: auto; }
        .rule-table .table-header { background-color: #fafafa; font-weight: 500; border-bottom: 1px solid #f0f0f0; position: sticky; top: 0; z-index: 10; }
        .rule-table .table-body { min-height: 0; }
        .rule-table .col-drag-handle { flex: 0 0 30px; text-align: center; }
        .rule-table .col-checkbox { flex: 0 0 40px; }
        .rule-table .col-rule-name {
            flex: 1;
            min-width: 200px;
            max-width: 300px;
            word-wrap: break-word;
            word-break: break-all;
            overflow-wrap: break-word;
            line-height: 1.4;
        }
        .rule-table .col-status { flex: 0 0 80px; text-align: center; }
        .rule-table .col-bound-group { flex: 0 0 120px; text-align: center; }
        .rule-table .col-rule-operation { flex: 0 0 200px; text-align: center; }
        .rule-table .col-rule-operation .btn { margin-left: 4px; }

        /* Drag handle styles for rule table */
        .rule-drag-handle {
            color: #999;
            cursor: grab;
            font-size: 16px;
            padding: 4px;
            transition: all 0.3s;
            border-radius: 3px;
        }
        .rule-drag-handle:hover {
            color: #666;
            background-color: #f0f0f0;
            transform: scale(1.1);
        }
        .rule-drag-handle:active {
            cursor: grabbing;
            background-color: #e6f7ff;
        }

        /* Dragging states for rule rows */
        .rule-table .table-row.dragging {
            opacity: 0.5;
            background-color: #f0f8ff;
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            position: relative;
        }

        .rule-table .table-row.drag-over {
            border-top: 2px solid #1890ff;
        }

        .rule-table .table-row.drag-over-bottom {
            border-bottom: 2px solid #1890ff;
        }

        /* Priority badge in rule table */
        .rule-priority-badge {
            background: #e6f7ff;
            color: #1890ff;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 11px;
            margin-right: 6px;
        }

        /* Status column styles */
        .status-enabled { color: #52c41a; font-weight: 500; }
        .status-disabled { color: #ff4d4f; font-weight: 500; }

        /* Rule action bar styles */
        .rule-action-bar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
        .rule-action-bar .search-input { position: relative; width: 36%; }
        .rule-action-bar .button-group { display: flex; gap: 8px; }

        /* Rule table content styles */
        .rule-name-content { display: flex; flex-direction: column; }
        .rule-name { font-weight: 500; margin-bottom: 4px; }
        .rule-details { display: flex; gap: 6px; margin-bottom: 4px; }
        .rule-pattern { font-size: 12px; color: #666; }
        .priority-badge, .binding-badge, .conflict-badge {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 3px;
            background-color: #f0f0f0;
            color: #666;
        }
        .binding-badge.create { background-color: #e6f7ff; color: #1890ff; }
        .binding-badge.existing { background-color: #f6ffed; color: #52c41a; }
        .conflict-badge { background-color: #fff2e8; color: #fa8c16; }
        .group-item { border-bottom: 1px solid #f0f0f0; }
        .group-item:last-child { border-bottom: none; }
        .group-header { display: flex; align-items: center; padding: 12px 16px; background-color: #fafafa; cursor: pointer; }
        .group-toggle {
            margin-right: 8px;
            font-size: 18px;
            font-weight: bold;
            width: 18px;
            text-align: center;
            line-height: 1;
        }
        .group-name { flex-grow: 1; font-weight: 500; }
        .group-content { display: none; padding: 16px; border-top: 1px solid #f0f0f0; }
        .group-item.expanded .group-content { display: block; }
        .nested-table .table-row { padding: 8px 12px; }
        .nested-table .col-name { flex: 1; }
        .delete-item { cursor: pointer; font-size: 16px; }
        .nested-pagination { justify-content: center; margin-top: 10px; }

        /* New Styles for Rule Management */
        .rule-section {
            background-color: #f5f7fa;
            padding: 12px 16px;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .rule-section:hover {
            background-color: #e6f7ff;
        }
        .rule-section.expanded {
            background-color: #e6f7ff;
        }
        .rule-summary {
            font-size: 14px;
            color: #333;
            display: flex;
            align-items: center;
        }
        .rule-count {
            color: #1890ff;
            font-weight: 500;
            margin-left: 5px;
        }
        .rule-toggle {
            margin-right: 8px;
            font-size: 16px;
            font-weight: bold;
            width: 16px;
            text-align: center;
            line-height: 1;
        }
        .manage-btn {
            font-size: 14px;
            color: #1890ff;
            cursor: pointer;
            text-decoration: none;
        }
        .manage-btn:hover {
            color: #40a9ff;
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }
        .modal-overlay.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-dialog {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.15);
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
        }
        .modal-dialog-header {
            padding: 16px 24px;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-dialog-title {
            font-size: 16px;
            font-weight: 500;
            margin: 0;
        }
        .modal-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #999;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-close:hover {
            color: #333;
        }
        .modal-dialog-body {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
        }
        .modal-dialog-footer {
            padding: 16px 24px;
            border-top: 1px solid #f0f0f0;
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        /* Rule List Styles */
        .rule-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        .rule-list {
            border: 1px solid #f0f0f0;
            border-radius: 4px;
        }
        .rule-item {
            background: #fff;
            border-bottom: 1px solid #f0f0f0;
            padding: 16px;
            transition: all 0.3s;
            cursor: move;
        }
        .rule-item:last-child {
            border-bottom: none;
        }
        .rule-item:hover {
            background-color: #fafafa;
        }
        .rule-item.dragging {
            opacity: 0.5;
        }
        .rule-item-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .drag-handle {
            margin-right: 12px;
            color: #999;
            cursor: move;
        }
        .rule-checkbox {
            margin-right: 12px;
        }
        .priority-badge {
            background: #e6f7ff;
            color: #1890ff;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            margin-right: 8px;
        }
        .rule-name {
            font-weight: 500;
            flex: 1;
        }
        .rule-actions {
            display: flex;
            gap: 8px;
        }
        .rule-pattern {
            color: #666;
            font-size: 13px;
            margin-left: 40px;
            margin-bottom: 4px;
        }
        .rule-stats {
            color: #999;
            font-size: 12px;
            margin-left: 40px;
        }

        /* Rule Editor Styles */
        .form-group {
            margin-bottom: 20px;
        }
        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 14px;
        }
        .form-label .required {
            color: #ff4d4f;
            margin-left: 4px;
        }
        .form-input, select.form-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d9d9d9;
            border-radius: 4px;
            font-size: 14px;
            transition: all 0.3s;
            background-color: #fff;
        }
        .form-input:focus, select.form-input:focus {
            border-color: #40a9ff;
            outline: none;
            box-shadow: 0 0 0 2px rgba(24, 144, 255, 0.2);
        }
        .radio-group {
            display: flex;
            gap: 24px;
            margin-top: 8px;
        }
        .radio-label {
            display: flex;
            align-items: center;
            font-size: 14px;
            cursor: pointer;
        }
        .radio-label input {
            margin-right: 6px;
        }
        .rule-syntax-help {
            background: #f5f7fa;
            border: 1px solid #e8e8e8;
            border-radius: 4px;
            padding: 12px;
            margin-top: 8px;
            font-size: 13px;
            line-height: 1.6;
        }
        .preview-section {
            margin-top: 16px;
            border: 1px solid #f0f0f0;
            border-radius: 4px;
            padding: 12px;
        }
        .preview-title {
            font-weight: 500;
            margin-bottom: 8px;
            font-size: 14px;
        }
        .preview-list {
            max-height: 150px;
            overflow-y: auto;
        }
        .preview-item {
            padding: 4px 0;
            font-size: 13px;
            color: #52c41a;
        }



        /* Enhanced Preview Styles */
        .preview-content {
            position: relative;
        }
        .preview-stats {
            background: #f0f8ff;
            border: 1px solid #d6e4ff;
            border-radius: 4px;
            padding: 8px 12px;
            margin-bottom: 12px;
            font-size: 13px;
        }
        .preview-stats .stat-item {
            margin-bottom: 4px;
        }
        .preview-stats .stat-item:last-child {
            margin-bottom: 0;
        }
        .preview-conflicts {
            background: #fff2e8;
            border: 1px solid #ffbb96;
            border-radius: 4px;
            padding: 8px 12px;
            margin-top: 8px;
        }
        .conflict-warning {
            color: #fa8c16;
            font-size: 13px;
            margin-bottom: 4px;
        }
        .conflict-warning:last-child {
            margin-bottom: 0;
        }
        .conflict-item {
            background: #fff1f0;
            border: 1px solid #ffccc7;
            border-radius: 3px;
            padding: 4px 8px;
            margin: 4px 0;
            font-size: 12px;
            color: #cf1322;
        }
        .preview-item::before {
            content: "âœ“ ";
            margin-right: 4px;
        }
        .preview-more {
            color: #1890ff;
            cursor: pointer;
            font-size: 13px;
            margin-top: 8px;
        }

        /* Auto-group indicator */
        .auto-grouped {
            background-color: #f6ffed;
            border: 1px solid #b7eb8f;
        }
        .auto-group-badge {
            background: #52c41a;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 11px;
            margin-left: 8px;
        }

        /* Syntax Help Styles */
        .input-hint {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
            line-height: 1.4;
        }
        .help-link {
            color: #1890ff;
            text-decoration: none;
            font-size: 12px;
            margin-left: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .help-link:hover {
            color: #40a9ff;
            text-decoration: underline;
        }
        .help-link:active {
            color: #096dd9;
        }
        .syntax-help-panel {
            background: #fafbfc;
            border: 1px solid #e8e8e8;
            border-radius: 6px;
            margin-top: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .help-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid #e8e8e8;
            background: #f0f8ff;
            border-radius: 6px 6px 0 0;
        }
        .help-header h4 {
            margin: 0;
            font-size: 14px;
            color: #1890ff;
        }
        .close-help {
            background: none;
            border: none;
            font-size: 18px;
            color: #999;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .close-help:hover {
            color: #666;
        }
        .help-content {
            padding: 16px;
        }
        .help-section {
            margin-bottom: 20px;
        }
        .help-section:last-child {
            margin-bottom: 0;
        }
        .help-section h5 {
            margin: 0 0 12px 0;
            font-size: 13px;
            color: #333;
            font-weight: 600;
        }
        .syntax-item {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
            padding: 6px 0;
        }
        .syntax-item code {
            background: #f5f5f5;
            border: 1px solid #d9d9d9;
            border-radius: 3px;
            padding: 2px 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #d4380d;
            min-width: 40px;
            text-align: center;
        }
        .syntax-desc {
            font-size: 12px;
            color: #666;
        }
        .example-item {
            margin-bottom: 12px;
            padding: 8px;
            background: #fff;
            border: 1px solid #e8e8e8;
            border-radius: 4px;
        }
        .example-pattern {
            margin-bottom: 4px;
        }
        .example-pattern code {
            background: #e6f7ff;
            border: 1px solid #91d5ff;
            border-radius: 3px;
            padding: 3px 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #1890ff;
            font-weight: 500;
        }
        .example-desc {
            font-size: 12px;
            color: #666;
            line-height: 1.4;
        }
        .tips-list {
            margin: 0;
            padding-left: 16px;
        }
        .tips-list li {
            font-size: 12px;
            color: #666;
            line-height: 1.5;
            margin-bottom: 6px;
        }

        /* Rule binding styles */
        .binding-badge {
            background: #f0f0f0;
            color: #666;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            margin-left: 8px;
        }
        .binding-badge.create {
            background: #e6f7ff;
            color: #1890ff;
        }
        .binding-badge.existing {
            background: #f6ffed;
            color: #52c41a;
        }
        
        /* Conflict indicator */
        .conflict-badge {
            background: #fff1f0;
            color: #ff4d4f;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            margin-left: 8px;
        }
        
        /* Rule item enhanced */
        .rule-item.has-conflict {
            border-left: 3px solid #ff4d4f;
        }
        
        /* Group stats styles */
        .group-stats {
            display: flex;
            gap: 8px;
            font-size: 12px;
            color: #999;
            margin-left: auto;
        }
        .group-stats-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .stats-icon {
            font-size: 14px;
        }

        /* System rule styles */
        .system-rule-row {
            background-color: #f6ffed !important;
            border-left: 3px solid #52c41a;
        }
        .system-rule-row:hover {
            background-color: #f6ffed !important;
        }
        .system-rule-badge {
            background: #52c41a;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            margin-right: 6px;
        }
        .system-rule-priority {
            background: #52c41a;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
        }

        /* Rule pattern text styles */
        .rule-pattern-text {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            color: #333;
            line-height: 1.4;
            display: block;
            margin-top: 2px;
        }

        .col-rule-name[title] {
            cursor: help;
        }

        .col-rule-name[title]:hover .rule-pattern-text {
            color: #1890ff;
        }
    </style>
</head>
<body>

<div class="modal-container">
    <!-- Header -->
    <div class="modal-header">
        <span class="title">è‡ªå®šä¹‰åˆ†ç»„</span>
        <a class="guide-link">ä½¿ç”¨æŒ‡å¼•</a>
    </div>

    <!-- Content -->
    <div class="modal-content">
        <!-- Left Panel -->
        <div class="panel left-panel">
            <div class="panel-header">
                <span class="panel-header-title">å¾…åˆ†ç»„ç»´åº¦åˆ—è¡¨ (ç±»å‹åç§°: æ‰‹æ¸¸æ“ä½œç³»ç»Ÿ)</span>
            </div>
            <div class="action-bar">
                <div class="search-input">
                     <span class="icon">ğŸ”</span>
                     <input type="text" id="search-items" placeholder="è¾“å…¥ç»´åº¦å€¼åç§°">
                </div>
                <button class="btn btn-primary">æ‰¹é‡å¯¼å…¥</button>
            </div>
            <div class="data-table">
                <div class="table-header">
                    <div class="col-checkbox"><input type="checkbox" id="select-all"></div>
                    <div class="col-name">ç»´åº¦åç§°</div>
                    <div class="col-group">åˆ†ç»„åç§°</div>
                </div>
                <div class="table-body" id="items-container"></div>
            </div>
            <div class="pagination" id="pagination-container"></div>
        </div>

        <!-- Middle Panel (åŸå³ä¾§é¢æ¿) -->
        <div class="panel middle-panel">
            <div class="panel-header">
                <input type="text" class="panel-header-title" placeholder="è¯·è¾“å…¥è‡ªå®šä¹‰åˆ†ç±»åç§°">
            </div>
            <div class="action-bar">
                 <div class="search-input">
                     <span class="icon">ğŸ”</span>
                     <input type="text" id="search-groups" placeholder="æœç´¢åˆ†ç»„æˆ–ç»´åº¦å€¼">
                </div>
                <div class="button-group">
                    <button class="btn btn-primary" id="btn-new-group">æ–°å»º</button>
                    <button class="btn btn-success" id="btn-match-groups">åŒ¹é…</button>
                    <button class="btn btn-default">å¯¼å…¥</button>
                    <button class="btn btn-default">åˆ é™¤</button>
                </div>
            </div>
            <div class="group-list-container" id="groups-container">
                <div class="group-table">
                    <div class="table-header">
                        <div class="col-checkbox"><input type="checkbox" id="select-all-groups"></div>
                        <div class="col-group-name">åˆ†ç»„åç§°</div>
                        <div class="col-operation">æ“ä½œ</div>
                    </div>
                    <div class="table-body" id="groups-table-body"></div>
                </div>
            </div>
        </div>
        
        <!-- Right Panel (æ–°å¢) -->
        <div class="panel right-panel">
            <div class="panel-header">
                <span class="panel-header-title">åŒ¹é…è§„åˆ™åˆ—è¡¨</span>
            </div>
            <!-- Rule Title Section -->
            <div class="rule-summary" style="margin-bottom: 16px;">
                <span>æ™ºèƒ½åˆ†ç»„è§„åˆ™</span>
                <span class="rule-count" id="rule-count">(0æ¡è§„åˆ™ç”Ÿæ•ˆä¸­)</span>
                <div style="font-size: 12px; color: #888; margin-top: 4px;">
                    ğŸ’¡ æç¤ºï¼šæ‹–æ‹½ â‹®â‹® å›¾æ ‡å¯è°ƒæ•´è§„åˆ™ä¼˜å…ˆçº§é¡ºåº
                </div>
            </div>

            <!-- Rule Action Bar -->
            <div class="rule-action-bar">
                <div class="search-input">
                    <span class="icon">ğŸ”</span>
                    <input type="text" id="search-rules" placeholder="æœç´¢è§„åˆ™åç§°æˆ–ç»‘å®šåˆ†ç»„">
                </div>
                <div class="button-group">
                    <button class="btn btn-primary" id="btn-new-rule-main">æ–°å»º</button>
                    <button class="btn btn-default" id="btn-batch-delete" disabled>åˆ é™¤</button>
                    <button class="btn btn-default" id="btn-batch-toggle" disabled>å¯ç”¨/æš‚åœ</button>
                    <button class="btn btn-default" id="btn-import-rules">å¯¼å…¥</button>
                    <button class="btn btn-default" id="btn-export-rules">å¯¼å‡º</button>
                </div>
                <!-- Hidden file input for import functionality -->
                <input type="file" id="import-file-input" accept=".json" style="display: none;">
            </div>

            <!-- Rule List Container with Table Structure -->
            <div class="rule-list-container" id="rule-list-container">
                <div class="rule-table">
                    <div class="rule-table-scroll-container">
                        <div class="table-header">
                            <div class="col-drag-handle"></div>
                            <div class="col-checkbox"><input type="checkbox" id="select-all-rules"></div>
                            <div class="col-rule-name">è§„åˆ™</div>
                            <div class="col-status">çŠ¶æ€</div>
                            <div class="col-bound-group">ç»‘å®šåˆ†ç»„</div>
                            <div class="col-rule-operation">æ“ä½œ</div>
                        </div>
                        <div class="table-body" id="rule-table-body">
                            <!-- è§„åˆ™åˆ—è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <div class="modal-footer">
        <div class="footer-left">
            <label class="checkbox-label">
                <input type="checkbox" checked>
                å°†æœªåˆ†ç»„ç»´åº¦å€¼å½’ç±»ä¸ºã€å…¶ä»–ã€‘
            </label>
        </div>
        <div class="footer-right">
            <button class="btn btn-default">å–æ¶ˆ</button>
            <button class="btn btn-primary">ä¿å­˜</button>
        </div>
    </div>
</div>

<!-- Rule Management Modal -->
<div class="modal-overlay" id="rule-modal">
    <div class="modal-dialog">
        <div class="modal-dialog-header">
            <h3 class="modal-dialog-title">æ™ºèƒ½åˆ†ç»„è§„åˆ™ç®¡ç†</h3>
            <button class="modal-close" id="close-rule-modal">Ã—</button>
        </div>
        <div class="modal-dialog-body">
            <div class="rule-toolbar">
                <div class="button-group">
                    <button class="btn btn-primary" id="btn-new-rule">æ–°å»ºè§„åˆ™</button>
                    <button class="btn btn-default">æ‰¹é‡å¯¼å…¥</button>
                    <button class="btn btn-default">å¯¼å‡ºè§„åˆ™</button>
                </div>
                <button class="btn btn-default" id="btn-test-rules">æµ‹è¯•è§„åˆ™</button>
            </div>
            <div class="rule-list" id="rule-list">
                <!-- Rules will be dynamically inserted here -->
            </div>
        </div>
        <div class="modal-dialog-footer">
            <button class="btn btn-default" id="cancel-rule-modal">å–æ¶ˆ</button>
            <button class="btn btn-primary" id="save-rule-modal">ä¿å­˜</button>
        </div>
    </div>
</div>

<!-- Rule Editor Modal -->
<div class="modal-overlay" id="rule-editor-modal">
    <div class="modal-dialog">
        <div class="modal-dialog-header">
            <h3 class="modal-dialog-title" id="rule-editor-title">æ–°å»ºåˆ†ç»„è§„åˆ™</h3>
            <button class="modal-close" id="close-rule-editor">Ã—</button>
        </div>
        <div class="modal-dialog-body">
            <form id="rule-editor-form">
                <div class="form-group">
                    <label class="form-label">ç»‘å®šç±»å‹</label>
                    <div class="radio-group">
                        <label class="radio-label">
                            <input type="radio" name="binding-type" value="existing" checked>
                            ç»‘å®šåˆ°å·²æœ‰åˆ†ç»„
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="binding-type" value="create">
                            åˆ›å»ºæ–°åˆ†ç»„
                        </label>
                    </div>
                </div>

                <div class="form-group" id="existing-group-section">
                    <label class="form-label">
                        é€‰æ‹©åˆ†ç»„<span class="required">*</span>
                    </label>
                    <select class="form-input" id="rule-group-select">
                        <option value="">è¯·é€‰æ‹©åˆ†ç»„</option>
                    </select>
                </div>

                <div class="form-group" id="new-group-section" style="display: none;">
                    <label class="form-label">
                        æ–°åˆ†ç»„åç§°<span class="required">*</span>
                    </label>
                    <input type="text" class="form-input" id="rule-group-name" placeholder="è¯·è¾“å…¥åˆ†ç»„åç§°">
                </div>
                
                <div class="form-group">
                    <label class="form-label">åŒ¹é…æ¨¡å¼</label>
                    <div class="radio-group">
                        <label class="radio-label">
                            <input type="radio" name="match-mode" value="keywords" checked>
                            å…³é”®è¯ç»„åˆ
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="match-mode" value="wildcard">
                            é€šé…ç¬¦åŒ¹é…
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="match-mode" value="regex">
                            æ­£åˆ™è¡¨è¾¾å¼
                        </label>
                    </div>
                </div>

                <div class="form-group" id="wildcard-section">
                    <label class="form-label">
                        åŒ¹é…è§„åˆ™<span class="required">*</span>
                    </label>
                    <input type="text" class="form-input" id="wildcard-pattern" placeholder="ä¾‹å¦‚ï¼šå¤´æ¡*">
                    <div class="input-hint" id="wildcard-hint">
                        ä½¿ç”¨ * ä»£è¡¨ä»»æ„å­—ç¬¦ï¼Œå¦‚ "å¤´æ¡*" åŒ¹é…æ‰€æœ‰ä»¥"å¤´æ¡"å¼€å¤´çš„ç»´åº¦å€¼
                        <a href="javascript:void(0)" class="help-link" id="wildcard-help-btn">è¯¦ç»†è§„åˆ™</a>
                    </div>
                    <div class="syntax-help-panel" id="wildcard-help-panel" style="display: none;">
                        <div class="help-header">
                            <h4>é€šé…ç¬¦åŒ¹é…è¯­æ³•æŒ‡å—</h4>
                            <button type="button" class="close-help" id="close-wildcard-help">Ã—</button>
                        </div>
                        <div class="help-content">
                            <div class="help-section">
                                <h5>åŸºç¡€è¯­æ³•</h5>
                                <div class="syntax-item">
                                    <code>*</code>
                                    <span class="syntax-desc">åŒ¹é…ä»»æ„æ•°é‡çš„å­—ç¬¦ï¼ˆåŒ…æ‹¬0ä¸ªï¼‰</span>
                                </div>
                                <div class="syntax-item">
                                    <code>?</code>
                                    <span class="syntax-desc">åŒ¹é…å•ä¸ªå­—ç¬¦</span>
                                </div>
                            </div>
                            <div class="help-section">
                                <h5>å¸¸ç”¨ç¤ºä¾‹</h5>
                                <div class="example-item">
                                    <div class="example-pattern"><code>å¤´æ¡*</code></div>
                                    <div class="example-desc">åŒ¹é…ï¼šå¤´æ¡ã€å¤´æ¡æ–°é—»ã€å¤´æ¡å¹¿å‘Šç­‰</div>
                                </div>
                                <div class="example-item">
                                    <div class="example-pattern"><code>*ç§»åŠ¨ç«¯</code></div>
                                    <div class="example-desc">åŒ¹é…ï¼šiOSç§»åŠ¨ç«¯ã€å®‰å“ç§»åŠ¨ç«¯ç­‰</div>
                                </div>
                                <div class="example-item">
                                    <div class="example-pattern"><code>*å¹¿å‘Š*</code></div>
                                    <div class="example-desc">åŒ¹é…ï¼šä¿¡æ¯æµå¹¿å‘Šã€è§†é¢‘å¹¿å‘Šã€æ¨ªå¹…å¹¿å‘Šç­‰</div>
                                </div>
                                <div class="example-item">
                                    <div class="example-pattern"><code>app_?</code></div>
                                    <div class="example-desc">åŒ¹é…ï¼šapp_1ã€app_2ã€app_aç­‰ï¼ˆå•ä¸ªå­—ç¬¦ï¼‰</div>
                                </div>
                            </div>
                            <div class="help-section">
                                <h5>å®ç”¨æŠ€å·§</h5>
                                <ul class="tips-list">
                                    <li>ä½¿ç”¨ * å¯ä»¥åŒ¹é…åŒ…å«ç‰¹å®šè¯æ±‡çš„æ‰€æœ‰ç»´åº¦å€¼</li>
                                    <li>? é€‚åˆåŒ¹é…æœ‰è§„å¾‹å˜åŒ–çš„ç»´åº¦å€¼ï¼Œå¦‚ç‰ˆæœ¬å·</li>
                                    <li>å¯ä»¥ç»„åˆä½¿ç”¨ï¼Œå¦‚ "v*_?" åŒ¹é…ç‰ˆæœ¬å·æ ¼å¼</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="syntax-help-panel" id="regex-help-panel" style="display: none;">
                        <div class="help-header">
                            <h4>æ­£åˆ™è¡¨è¾¾å¼ç®€æ˜“æŒ‡å—</h4>
                            <button type="button" class="close-help" id="close-regex-help">Ã—</button>
                        </div>
                        <div class="help-content">
                            <div class="help-section">
                                <h5>åŸºç¡€è¯­æ³•</h5>
                                <div class="syntax-item">
                                    <code>^</code>
                                    <span class="syntax-desc">åŒ¹é…æ–‡æœ¬çš„å¼€å¤´</span>
                                </div>
                                <div class="syntax-item">
                                    <code>$</code>
                                    <span class="syntax-desc">åŒ¹é…æ–‡æœ¬çš„ç»“å°¾</span>
                                </div>
                                <div class="syntax-item">
                                    <code>.</code>
                                    <span class="syntax-desc">åŒ¹é…ä»»æ„å•ä¸ªå­—ç¬¦</span>
                                </div>
                                <div class="syntax-item">
                                    <code>.*</code>
                                    <span class="syntax-desc">åŒ¹é…ä»»æ„æ•°é‡çš„ä»»æ„å­—ç¬¦</span>
                                </div>
                                <div class="syntax-item">
                                    <code>[abc]</code>
                                    <span class="syntax-desc">åŒ¹é…æ–¹æ‹¬å·å†…çš„ä»»æ„ä¸€ä¸ªå­—ç¬¦</span>
                                </div>
                                <div class="syntax-item">
                                    <code>(a|b)</code>
                                    <span class="syntax-desc">åŒ¹é…aæˆ–b</span>
                                </div>
                            </div>
                            <div class="help-section">
                                <h5>å¸¸ç”¨ç¤ºä¾‹</h5>
                                <div class="example-item">
                                    <div class="example-pattern"><code>^å¤´æ¡</code></div>
                                    <div class="example-desc">åŒ¹é…æ‰€æœ‰ä»¥"å¤´æ¡"å¼€å¤´çš„ç»´åº¦å€¼</div>
                                </div>
                                <div class="example-item">
                                    <div class="example-pattern"><code>ç§»åŠ¨ç«¯$</code></div>
                                    <div class="example-desc">åŒ¹é…æ‰€æœ‰ä»¥"ç§»åŠ¨ç«¯"ç»“å°¾çš„ç»´åº¦å€¼</div>
                                </div>
                                <div class="example-item">
                                    <div class="example-pattern"><code>^(ios|android)$</code></div>
                                    <div class="example-desc">ç²¾ç¡®åŒ¹é…"ios"æˆ–"android"</div>
                                </div>
                                <div class="example-item">
                                    <div class="example-pattern"><code>å¹¿å‘Š.*æ•ˆæœ</code></div>
                                    <div class="example-desc">åŒ¹é…å…ˆæœ‰"å¹¿å‘Š"åæœ‰"æ•ˆæœ"çš„ç»´åº¦å€¼</div>
                                </div>
                            </div>
                            <div class="help-section">
                                <h5>å®ç”¨æŠ€å·§</h5>
                                <ul class="tips-list">
                                    <li>ä½¿ç”¨ ^ å’Œ $ å¯ä»¥ç²¾ç¡®åŒ¹é…æ•´ä¸ªç»´åº¦å€¼</li>
                                    <li>ä½¿ç”¨ (é€‰é¡¹1|é€‰é¡¹2) å¯ä»¥åŒ¹é…å¤šä¸ªå¯èƒ½çš„å€¼</li>
                                    <li>å¦‚æœä¸ç¡®å®šå¦‚ä½•ä½¿ç”¨ï¼Œå¯ä»¥å…ˆå°è¯•é€šé…ç¬¦åŒ¹é…</li>
                                    <li>æ­£åˆ™è¡¨è¾¾å¼æ¯”é€šé…ç¬¦æ›´å¼ºå¤§ï¼Œä½†ä¹Ÿæ›´å¤æ‚</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="form-group" id="keywords-section" style="display: none;">
                    <label class="form-label">åŒ…å«å…³é”®è¯</label>
                    <div id="include-keywords">
                        <!-- Keywords will be added here -->
                    </div>
                    <button type="button" class="btn btn-default btn-sm" id="add-include-keyword">+ æ·»åŠ å…³é”®è¯</button>
                    
                    <label class="form-label" style="margin-top: 16px;">æ’é™¤å…³é”®è¯</label>
                    <div id="exclude-keywords">
                        <!-- Keywords will be added here -->
                    </div>
                    <button type="button" class="btn btn-default btn-sm" id="add-exclude-keyword">+ æ·»åŠ æ’é™¤è¯</button>
                </div>

                <!-- Priority Configuration Section -->
                <div class="form-group" id="priority-section" style="display: none;">
                    <label class="form-label">ä¼˜å…ˆçº§é…ç½®</label>
                    <select class="form-input" id="priority-select">
                        <option value="highest">æœ€é«˜ä¼˜å…ˆçº§</option>
                        <option value="lowest" selected>æœ€ä½ä¼˜å…ˆçº§</option>
                    </select>
                </div>

                <div class="preview-section">
                    <div class="preview-title">å®æ—¶é¢„è§ˆ</div>
                    <div class="preview-content">
                        <div class="preview-stats" id="preview-stats">
                            <!-- Preview statistics will be shown here -->
                        </div>
                        <div class="preview-list" id="preview-list">
                            <!-- Preview items will be shown here -->
                        </div>
                        <div class="preview-conflicts" id="preview-conflicts" style="display: none;">
                            <!-- Conflict warnings will be shown here -->
                        </div>
                        <div class="preview-more" id="preview-more" style="display: none;">æŸ¥çœ‹å…¨éƒ¨...</div>
                    </div>
                </div>
            </form>
        </div>
        <div class="modal-dialog-footer">
            <button class="btn btn-default" id="cancel-rule-editor">å–æ¶ˆ</button>
            <button class="btn btn-primary" id="save-rule-editor">ä¿å­˜</button>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {

    // --- 1. STATE MANAGEMENT ---
    let allItems = [
        { id: 1, name: 'switch', group: 'åˆ†ç»„1', isAutoGrouped: false }, 
        { id: 2, name: 'ps', group: 'åˆ†ç»„2', isAutoGrouped: false },
        { id: 3, name: 'web_android', group: 'åˆ†ç»„2', isAutoGrouped: false }, 
        { id: 4, name: 'web_ios', group: 'å¾…åˆ†ç»„', isAutoGrouped: false },
        { id: 5, name: 'xbox', group: 'åˆ†ç»„1', isAutoGrouped: false }, 
        { id: 6, name: 'chromeos', group: 'å¾…åˆ†ç»„', isAutoGrouped: false },
        { id: 7, name: 'popo_mini', group: 'å¾…åˆ†ç»„', isAutoGrouped: false }, 
        { id: 8, name: 'ios', group: 'åˆ†ç»„1', isAutoGrouped: false },
        { id: 9, name: 'android', group: 'ç§»åŠ¨ç«¯', isAutoGrouped: false }, 
        { id: 10, name: 'windows', group: 'PCç«¯', isAutoGrouped: false },
        { id: 11, name: 'macos', group: 'å¾…åˆ†ç»„', isAutoGrouped: false }, 
        { id: 12, name: 'linux', group: 'å¾…åˆ†ç»„', isAutoGrouped: false },
        { id: 13, name: 'playstation5', group: 'åˆ†ç»„1', isAutoGrouped: false }, 
        { id: 14, name: 'xbox_series_x', group: 'åˆ†ç»„1', isAutoGrouped: false },
        { id: 15, name: 'nintendo_wii', group: 'å¾…åˆ†ç»„', isAutoGrouped: false }, 
        { id: 16, name: 'steam_deck', group: 'å¾…åˆ†ç»„', isAutoGrouped: false },
        { id: 17, name: 'ipad_os', group: 'ç§»åŠ¨ç«¯', isAutoGrouped: false }, 
        { id: 18, name: 'harmony_os', group: 'å¾…åˆ†ç»„', isAutoGrouped: false },
        { id: 19, name: 'ubuntu', group: 'å¾…åˆ†ç»„', isAutoGrouped: false }, 
        { id: 20, name: 'symbian', group: 'å¾…åˆ†ç»„', isAutoGrouped: false },
        // Add more test data for rule matching
        { id: 21, name: 'ä»Šæ—¥å¤´æ¡(æ•ˆæœ)', group: 'å¾…åˆ†ç»„', isAutoGrouped: false },
        { id: 22, name: 'å¤´æ¡ç›´æ’­(æ•ˆæœ)', group: 'å¾…åˆ†ç»„', isAutoGrouped: false },
        { id: 23, name: 'å¤´æ¡åŸç”Ÿ(æ•ˆæœ)', group: 'å¾…åˆ†ç»„', isAutoGrouped: false },
        { id: 24, name: 'æŠ–éŸ³ç›´æ’­', group: 'å¾…åˆ†ç»„', isAutoGrouped: false },
        { id: 25, name: 'æŠ–éŸ³ä¿¡æ¯æµ', group: 'å¾…åˆ†ç»„', isAutoGrouped: false },
        { id: 26, name: 'å¿«æ‰‹æ•ˆæœ', group: 'å¾…åˆ†ç»„', isAutoGrouped: false },
    ];
    
    let groups = ['åˆ†ç»„1', 'åˆ†ç»„2', 'PCç«¯', 'ç§»åŠ¨ç«¯'];
    
    // Rule management state
    let groupRules = [];
    let editingRuleId = null;
    
    // Enhanced rule data structure
    const createRule = (data) => ({
        id: data.id || `rule_${Date.now()}`,
        name: data.name || '',
        groupName: data.groupName,
        bindingType: data.bindingType || 'existing', // 'existing' or 'create'
        priority: data.priority || groupRules.length + 1,
        enabled: data.enabled !== false,
        matchMode: data.matchMode || 'wildcard', // 'wildcard', 'regex', 'exact', 'keywords'
        rule: data.rule || { type: 'wildcard', pattern: '' },
        isSystemRule: data.isSystemRule || false, // æ ‡è¯†ç³»ç»Ÿè§„åˆ™
        stats: {
            matchCount: 0,
            lastMatched: null,
            conflictCount: 0
        },
        createdAt: data.createdAt || new Date().toISOString(),
        updatedAt: data.updatedAt || new Date().toISOString()
    });

    // Create system default rule for unmatched items
    const createSystemDefaultRule = () => ({
        id: 'system_default_rule',
        name: 'æœªåŒ¹é…ç»´åº¦å€¼è‡ªåŠ¨åŠ å…¥å…¶ä»–',
        groupName: 'å…¶ä»–',
        bindingType: 'existing',
        priority: 9999, // æœ€ä½ä¼˜å…ˆçº§
        enabled: false, // é»˜è®¤ç¦ç”¨ï¼Œéœ€è¦ç”¨æˆ·ä¸»åŠ¨å¯ç”¨
        matchMode: 'system',
        rule: { type: 'system', pattern: 'catch_all' },
        isSystemRule: true,
        stats: {
            matchCount: 0,
            lastMatched: null,
            conflictCount: 0
        },
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
    });

    // Ensure system rule and "å…¶ä»–" group exist
    const ensureSystemRule = () => {
        // ç¡®ä¿"å…¶ä»–"åˆ†ç»„å­˜åœ¨
        if (!groups.includes('å…¶ä»–')) {
            groups.push('å…¶ä»–');
        }

        // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç³»ç»Ÿè§„åˆ™
        const existingSystemRule = groupRules.find(rule => rule.isSystemRule);
        if (!existingSystemRule) {
            const systemRule = createSystemDefaultRule();
            groupRules.push(systemRule);
        }
    };

    // Save user rules to localStorage (exclude system rules)
    const saveRulesToStorage = () => {
        const userRules = groupRules.filter(rule => !rule.isSystemRule);
        localStorage.setItem('groupRules', JSON.stringify(userRules));
    };
    
    // State for left panel
    let mainCurrentPage = 1;
    const mainItemsPerPage = 10;
    let itemFilter = '';

    // State for right panel
    let groupFilter = '';
    let ruleFilter = '';
    let expandedGroups = new Set();
    let groupPagination = {};
    const nestedItemsPerPage = 5;

    // --- 2. DOM ELEMENTS ---
    const itemsContainer = document.getElementById('items-container');
    const groupsContainer = document.getElementById('groups-container');
    const groupsTableBody = document.getElementById('groups-table-body');
    const searchItemsInput = document.getElementById('search-items');
    const searchGroupsInput = document.getElementById('search-groups');
    const selectAllCheckbox = document.getElementById('select-all');
    const selectAllGroupsCheckbox = document.getElementById('select-all-groups');
    const paginationContainer = document.getElementById('pagination-container');
    const btnNewGroup = document.getElementById('btn-new-group');
    const btnMatchGroups = document.getElementById('btn-match-groups');
    
    // Rule management elements
    const ruleModal = document.getElementById('rule-modal');
    const ruleEditorModal = document.getElementById('rule-editor-modal');
    const ruleList = document.getElementById('rule-list');
    const ruleListContainer = document.getElementById('rule-list-container');
    const ruleTableBody = document.getElementById('rule-table-body');
    const searchRulesInput = document.getElementById('search-rules');
    const selectAllRulesCheckbox = document.getElementById('select-all-rules');
    const btnNewRule = document.getElementById('btn-new-rule');
    const btnNewRuleMain = document.getElementById('btn-new-rule-main');
    const btnTestRules = document.getElementById('btn-test-rules');
    const btnBatchDelete = document.getElementById('btn-batch-delete');
    const btnBatchToggle = document.getElementById('btn-batch-toggle');
    const btnImportRules = document.getElementById('btn-import-rules');
    const btnExportRules = document.getElementById('btn-export-rules');
    const importFileInput = document.getElementById('import-file-input');
    const ruleCount = document.getElementById('rule-count');

    // --- 3. RULE ENGINE ---
    
    // Convert wildcard pattern to regex
    const wildcardToRegex = (pattern) => {
        // Escape special regex characters except * and ?
        let escaped = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&');
        // Replace wildcards
        escaped = escaped.replace(/\*/g, '.*');
        escaped = escaped.replace(/\?/g, '.');
        return new RegExp(`^${escaped}$`, 'i');
    };

    // Match item against a rule with multiple modes
    const matchRule = (itemName, rule) => {
        switch (rule.type) {
            case 'wildcard':
                const wildcardRegex = wildcardToRegex(rule.pattern);
                return wildcardRegex.test(itemName);

            case 'regex':
                try {
                    const regex = new RegExp(rule.pattern, 'i');
                    return regex.test(itemName);
                } catch (e) {
                    console.error('Invalid regex pattern:', rule.pattern);
                    return false;
                }

            case 'exact':
                return itemName.toLowerCase() === rule.pattern.toLowerCase();

            case 'keywords':
                const lowerName = itemName.toLowerCase();
                // Check include keywords (AND logic)
                if (rule.includeKeywords && rule.includeKeywords.length > 0) {
                    const hasAllIncluded = rule.includeKeywords.every(keyword =>
                        lowerName.includes(keyword.toLowerCase())
                    );
                    if (!hasAllIncluded) return false;
                }
                // Check exclude keywords
                if (rule.excludeKeywords && rule.excludeKeywords.length > 0) {
                    const hasExcluded = rule.excludeKeywords.some(keyword =>
                        lowerName.includes(keyword.toLowerCase())
                    );
                    if (hasExcluded) return false;
                }
                return true;

            case 'system':
                // ç³»ç»Ÿè§„åˆ™æ€»æ˜¯åŒ¹é…æ‰€æœ‰é¡¹ç›®ï¼Œä½œä¸ºå…œåº•è§„åˆ™
                return true;

            default:
                return false;
        }
    };

    // Apply rules to all items with conflict detection
    const applyRules = () => {
        // Ensure system rule exists
        ensureSystemRule();

        // Reset auto-grouped items and stats
        allItems.forEach(item => {
            if (item.isAutoGrouped) {
                item.group = 'å¾…åˆ†ç»„';
                item.isAutoGrouped = false;
                item.appliedRuleId = null;
            }
        });

        // Reset rule stats
        groupRules.forEach(rule => {
            rule.stats.matchCount = 0;
            rule.stats.conflictCount = 0;
        });

        // Separate system rules and user rules
        const userRules = groupRules.filter(rule => !rule.isSystemRule && rule.enabled);
        const systemRules = groupRules.filter(rule => rule.isSystemRule && rule.enabled);

        // Sort user rules by priority
        const sortedUserRules = [...userRules].sort((a, b) => a.priority - b.priority);

        // Track conflicts
        const conflictMap = new Map(); // item.id -> [rule.id, ...]

        // Apply user rules first
        allItems.forEach(item => {
            // Skip manually grouped items
            if (item.group !== 'å¾…åˆ†ç»„') return;

            const matchingRules = [];

            // Find all matching user rules
            for (const rule of sortedUserRules) {
                if (matchRule(item.name, rule.rule || rule)) {
                    matchingRules.push(rule);
                }
            }

            if (matchingRules.length > 0) {
                // Apply the highest priority rule
                const appliedRule = matchingRules[0];
                item.group = appliedRule.groupName;
                item.isAutoGrouped = true;
                item.appliedRuleId = appliedRule.id;
                appliedRule.stats.matchCount++;
                appliedRule.stats.lastMatched = new Date().toISOString();

                // Handle binding type
                if (appliedRule.bindingType === 'create' && !groups.includes(appliedRule.groupName)) {
                    groups.push(appliedRule.groupName);
                }

                // Check for conflicts (multiple rules with same priority)
                const samePriorityRules = matchingRules.filter(r => r.priority === appliedRule.priority);
                if (samePriorityRules.length > 1) {
                    conflictMap.set(item.id, samePriorityRules.map(r => r.id));
                    samePriorityRules.forEach(r => r.stats.conflictCount++);
                }
            }
        });

        // Apply system rules to remaining unmatched items
        systemRules.forEach(systemRule => {
            allItems.forEach(item => {
                // Only apply to items that are still in "å¾…åˆ†ç»„" state
                if (item.group === 'å¾…åˆ†ç»„') {
                    item.group = systemRule.groupName;
                    item.isAutoGrouped = true;
                    item.appliedRuleId = systemRule.id;
                    systemRule.stats.matchCount++;
                    systemRule.stats.lastMatched = new Date().toISOString();
                }
            });
        });

        // Store conflict information
        window.ruleConflicts = conflictMap;

        renderAll();
    };

    // --- 4. RENDER FUNCTIONS ---

    const renderAll = () => {
        renderItems();
        renderGroups();
        renderRuleListInPanel();
        updateRuleCount();
    }

    const updateRuleCount = () => {
        const enabledCount = groupRules.filter(r => r.enabled).length;
        ruleCount.textContent = `(${enabledCount}æ¡è§„åˆ™ç”Ÿæ•ˆä¸­)`;
    };

    // Renders the list of items on the left
    const renderItems = () => {
        const filteredItems = allItems.filter(item =>
            item.name.toLowerCase().includes(itemFilter.toLowerCase())
        );
        const startIndex = (mainCurrentPage - 1) * mainItemsPerPage;
        const paginatedItems = filteredItems.slice(startIndex, startIndex + mainItemsPerPage);
        
        itemsContainer.innerHTML = '';
        paginatedItems.forEach(item => {
            const row = document.createElement('div');
            row.className = `table-row ${item.isAutoGrouped ? 'auto-grouped' : ''}`;
            row.innerHTML = `
                <div class="col-checkbox"><input type="checkbox" class="item-checkbox" data-id="${item.id}"></div>
                <div class="col-name">${item.name}</div>
                <div class="col-group">
                    ${item.group}
                    ${item.isAutoGrouped ? '<span class="auto-group-badge">è‡ªåŠ¨</span>' : ''}
                </div>
            `;
            itemsContainer.appendChild(row);
        });

        renderMainPagination(filteredItems.length);
        updateSelectAllCheckbox();
    };

    // Renders the table-style groups list
    const renderGroups = () => {
        const filteredGroups = groups.filter(g => g.toLowerCase().includes(groupFilter.toLowerCase()));
        groupsTableBody.innerHTML = '';

        filteredGroups.forEach(groupName => {
            // Find items for this group
            const itemsInGroup = allItems.filter(item => item.group === groupName);

            // Find matching enabled rule for this group
            const matchingRule = groupRules.find(rule =>
                rule.enabled && rule.groupName === groupName
            );

            // Create table row for each group
            const groupRow = document.createElement('div');
            groupRow.className = 'table-row';
            groupRow.dataset.groupName = groupName;

            // Build auto badge HTML if there's a matching rule
            const autoBadgeHtml = matchingRule ?
                `<span class="auto-badge" data-rule-id="${matchingRule.id}">è‡ªåŠ¨</span>` : '';

            groupRow.innerHTML = `
                <div class="col-checkbox">
                    <input type="checkbox" class="group-checkbox" data-group="${groupName}">
                </div>
                <div class="col-group-name">
                    <span class="group-name">${groupName}</span>
                    <span class="group-count">(${itemsInGroup.length}é¡¹)</span>
                    ${autoBadgeHtml}
                </div>
                <div class="col-operation">
                    <button class="btn btn-primary btn-sm add-to-group" data-group="${groupName}">åŠ å…¥</button>
                </div>
            `;

            groupsTableBody.appendChild(groupRow);
        });
    };

    // Renders main pagination (left panel)
    const renderMainPagination = (totalItems) => {
        const totalPages = Math.ceil(totalItems / mainItemsPerPage);
        paginationContainer.innerHTML = totalPages > 1 ? `
            <button class="pagination-btn" id="prev-page" ${mainCurrentPage === 1 ? 'disabled' : ''}>&lt;</button>
            <span>${mainCurrentPage} / ${totalPages}</span>
            <button class="pagination-btn" id="next-page" ${mainCurrentPage < totalPages ? '' : 'disabled'}>&gt;</button>
        ` : '';
    };

    // Renders nested pagination (right panel) and returns as string
    const renderNestedPagination = (totalItems, currentPage, groupName) => {
        const totalPages = Math.ceil(totalItems / nestedItemsPerPage);
        return totalPages > 1 ? `
            <div class="pagination nested-pagination">
                <button class="pagination-btn nested-prev-page" data-group-name="${groupName}" ${currentPage === 1 ? 'disabled' : ''}>&lt;</button>
                <span>${currentPage} / ${totalPages}</span>
                <button class="pagination-btn nested-next-page" data-group-name="${groupName}" ${currentPage < totalPages ? '' : 'disabled'}>&gt;</button>
            </div>
        ` : '';
    };

    // Render rule list with enhanced information
    const renderRuleList = () => {
        ruleList.innerHTML = '';
        
        if (groupRules.length === 0) {
            ruleList.innerHTML = '<div style="text-align: center; padding: 40px; color: #999;">æš‚æ— è§„åˆ™ï¼Œç‚¹å‡»"æ–°å»ºè§„åˆ™"æ·»åŠ </div>';
            return;
        }

        groupRules.forEach((rule, index) => {
            const ruleItem = document.createElement('div');
            ruleItem.className = 'rule-item';
            if (rule.stats && rule.stats.conflictCount > 0) {
                ruleItem.className += ' has-conflict';
            }
            ruleItem.dataset.ruleId = rule.id;
            
            // Get pattern display text
            let patternText = '';
            if (rule.rule) {
                if (rule.rule.pattern) {
                    patternText = rule.rule.pattern;
                } else if (rule.rule.type === 'keywords') {
                    const includes = rule.rule.includeKeywords || [];
                    const excludes = rule.rule.excludeKeywords || [];
                    patternText = `åŒ…å«: ${includes.join(', ') || 'æ— '} | æ’é™¤: ${excludes.join(', ') || 'æ— '}`;
                }
            } else if (rule.pattern) {
                patternText = rule.pattern;
            }

            ruleItem.innerHTML = `
                <div class="rule-item-header">
                    <span class="drag-handle">â‰¡</span>
                    <input type="checkbox" class="rule-checkbox" ${rule.enabled ? 'checked' : ''}>
                    <span class="priority-badge">ä¼˜å…ˆçº§${rule.priority}</span>
                    <span class="rule-name">${rule.groupName}</span>
                    ${rule.bindingType === 'create' ? '<span class="binding-badge create">åˆ›å»ºåˆ†ç»„</span>' : '<span class="binding-badge existing">ç»‘å®šåˆ†ç»„</span>'}
                    ${rule.stats && rule.stats.conflictCount > 0 ? `<span class="conflict-badge">å†²çª ${rule.stats.conflictCount}</span>` : ''}
                    <div class="rule-actions">
                        <button class="btn btn-default btn-sm edit-rule">ç¼–è¾‘</button>
                        <button class="btn btn-default btn-sm delete-rule">åˆ é™¤</button>
                    </div>
                </div>
                <div class="rule-pattern">
                    <strong>${rule.matchMode || rule.rule?.type || 'keywords'}:</strong> ${patternText}
                </div>
                <div class="rule-stats">
                    åŒ¹é…æ•°ï¼š${rule.stats?.matchCount || 0}ä¸ªç»´åº¦å€¼
                    ${rule.stats?.lastMatched ? ` | æœ€ååŒ¹é…ï¼š${new Date(rule.stats.lastMatched).toLocaleString('zh-CN')}` : ''}
                </div>
            `;
            
            ruleList.appendChild(ruleItem);
        });
    };
    
    // åœ¨å³ä¾§é¢æ¿ä¸­æ¸²æŸ“è§„åˆ™åˆ—è¡¨
    const renderRuleListInPanel = () => {
        ruleTableBody.innerHTML = '';

        // åˆ†ç¦»ç”¨æˆ·è§„åˆ™å’Œç³»ç»Ÿè§„åˆ™
        const userRules = groupRules.filter(rule => !rule.isSystemRule);
        const systemRules = groupRules.filter(rule => rule.isSystemRule);

        // è¿‡æ»¤ç”¨æˆ·è§„åˆ™
        const filteredUserRules = userRules.filter(rule => {
            if (!ruleFilter) return true;
            const searchText = ruleFilter.toLowerCase();
            return rule.groupName.toLowerCase().includes(searchText) ||
                   (rule.rule?.pattern && rule.rule.pattern.toLowerCase().includes(searchText)) ||
                   (rule.pattern && rule.pattern.toLowerCase().includes(searchText));
        });

        // è¿‡æ»¤ç³»ç»Ÿè§„åˆ™
        const filteredSystemRules = systemRules.filter(rule => {
            if (!ruleFilter) return true;
            const searchText = ruleFilter.toLowerCase();
            return rule.groupName.toLowerCase().includes(searchText) ||
                   rule.name.toLowerCase().includes(searchText);
        });

        const allFilteredRules = [...filteredUserRules, ...filteredSystemRules];

        if (allFilteredRules.length === 0) {
            ruleTableBody.innerHTML = '<div style="text-align: center; padding: 40px; color: #999; grid-column: 1 / -1;">æš‚æ— åŒ¹é…çš„è§„åˆ™</div>';
            return;
        }

        allFilteredRules.forEach((rule, index) => {
            // è·å–è§„åˆ™æ˜¾ç¤ºæ–‡æœ¬å’Œå®Œæ•´æè¿°
            let patternText = '';
            let fullPatternText = '';

            if (rule.isSystemRule) {
                patternText = 'è‡ªåŠ¨æ•è·æ‰€æœ‰æœªåŒ¹é…çš„ç»´åº¦å€¼';
                fullPatternText = patternText;
            } else if (rule.rule) {
                switch (rule.rule.type) {
                    case 'wildcard':
                        patternText = rule.rule.pattern || '';
                        fullPatternText = `é€šé…ç¬¦åŒ¹é…: ${patternText}`;
                        break;
                    case 'regex':
                        patternText = rule.rule.pattern || '';
                        fullPatternText = `æ­£åˆ™è¡¨è¾¾å¼: ${patternText}`;
                        break;
                    case 'exact':
                        patternText = rule.rule.pattern || '';
                        fullPatternText = `ç²¾ç¡®åŒ¹é…: ${patternText}`;
                        break;
                    case 'keywords':
                        const includes = rule.rule.includeKeywords || [];
                        const excludes = rule.rule.excludeKeywords || [];
                        patternText = `åŒ…å«: ${includes.join(', ') || 'æ— '} | æ’é™¤: ${excludes.join(', ') || 'æ— '}`;
                        fullPatternText = `å…³é”®è¯åŒ¹é… - ${patternText}`;
                        break;
                    default:
                        // å…¼å®¹æ—§ç‰ˆæœ¬æ•°æ®ç»“æ„
                        patternText = rule.rule.pattern || '';
                        fullPatternText = patternText;
                }
            } else if (rule.pattern) {
                // å…¼å®¹æ—§ç‰ˆæœ¬æ•°æ®ç»“æ„
                patternText = rule.pattern;
                fullPatternText = patternText;
            }

            // å¤„ç†é•¿æ–‡æœ¬æˆªæ–­
            const maxLength = 40;
            const displayText = patternText.length > maxLength ?
                patternText.substring(0, maxLength) + '...' : patternText;

            const ruleRow = document.createElement('div');
            ruleRow.className = rule.isSystemRule ? 'table-row system-rule-row' : 'table-row';
            if (rule.stats && rule.stats.conflictCount > 0) {
                ruleRow.className += ' has-conflict';
            }
            ruleRow.dataset.ruleId = rule.id;

            // ç³»ç»Ÿè§„åˆ™çš„ç‰¹æ®Šæ˜¾ç¤º
            const priorityDisplay = rule.isSystemRule ?
                '<span class="system-rule-priority">å…œåº•è§„åˆ™</span>' :
                `<span class="rule-priority-badge">ä¼˜å…ˆçº§${rule.priority}</span>`;

            const dragHandle = rule.isSystemRule ?
                '<span style="color: #ccc;">ğŸ”’</span>' :
                '<span class="rule-drag-handle" draggable="true">â‹®â‹®</span>';

            const systemBadge = rule.isSystemRule ?
                '<span class="system-rule-badge">ç³»ç»Ÿ</span>' : '';

            const operationButtons = rule.isSystemRule ?
                '<span style="color: #999; font-size: 12px;">ç³»ç»Ÿè§„åˆ™</span>' :
                `<div class="priority-btn-group">
                    <button class="btn-priority priority-top" data-rule-id="${rule.id}" title="ç½®é¡¶" ${index === 0 ? 'disabled' : ''}>â‡ˆ</button>
                    <button class="btn-priority priority-up" data-rule-id="${rule.id}" title="ä¸Šç§»ä¸€ä½" ${index === 0 ? 'disabled' : ''}>â†‘</button>
                    <button class="btn-priority priority-down" data-rule-id="${rule.id}" title="ä¸‹ç§»ä¸€ä½" ${index === allFilteredRules.length - 1 ? 'disabled' : ''}>â†“</button>
                    <button class="btn-priority priority-bottom" data-rule-id="${rule.id}" title="ç½®åº•" ${index === allFilteredRules.length - 1 ? 'disabled' : ''}>â‡Š</button>
                </div>
                <button class="btn btn-default btn-sm edit-rule-panel" data-rule-id="${rule.id}">âš™</button>`;

            ruleRow.innerHTML = `
                <div class="col-drag-handle">
                    ${dragHandle}
                </div>
                <div class="col-checkbox">
                    <input type="checkbox" class="rule-checkbox" data-rule-id="${rule.id}" ${rule.enabled ? 'checked' : ''}>
                </div>
                <div class="col-rule-name" title="${fullPatternText}">
                    ${priorityDisplay}
                    ${systemBadge}
                    <span class="rule-pattern-text">${displayText}</span>
                </div>
                <div class="col-status">
                    <span class="${rule.enabled ? 'status-enabled' : 'status-disabled'}">
                        ${rule.enabled ? 'å·²å¯ç”¨' : 'å·²æš‚åœ'}
                    </span>
                </div>
                <div class="col-bound-group">
                    <div class="bound-group-name">${rule.groupName}</div>
                    <div style="font-size: 12px; color: #888; margin-top: 2px;">
                        åŒ¹é…${rule.stats?.matchCount || 0}é¡¹
                    </div>
                </div>
                <div class="col-rule-operation">
                    ${operationButtons}
                </div>
            `;

            ruleTableBody.appendChild(ruleRow);
        });

        // æ›´æ–°å…¨é€‰å¤é€‰æ¡†çŠ¶æ€
        updateSelectAllRulesCheckbox();
    };
    
    // å³ä¾§é¢æ¿ä¸­çš„è§„åˆ™åˆ—è¡¨äº‹ä»¶
    ruleListContainer.addEventListener('click', (e) => {
        const tableRow = e.target.closest('.table-row');
        if (!tableRow) return;

        const ruleId = tableRow.dataset.ruleId;
        const rule = groupRules.find(r => r.id === ruleId);

        // ç¼–è¾‘è§„åˆ™
        if (e.target.classList.contains('edit-rule-panel')) {
            // é˜²æ­¢ç¼–è¾‘ç³»ç»Ÿè§„åˆ™
            if (rule.isSystemRule) {
                alert('ç³»ç»Ÿè§„åˆ™ä¸èƒ½ç¼–è¾‘');
                return;
            }

            editingRuleId = ruleId;
            document.getElementById('rule-editor-title').textContent = 'ç¼–è¾‘åˆ†ç»„è§„åˆ™';

            // å¡«å……å·²æœ‰åˆ†ç»„ä¸‹æ‹‰æ¡†
            const groupSelect = document.getElementById('rule-group-select');
            groupSelect.innerHTML = '<option value="">è¯·é€‰æ‹©åˆ†ç»„</option>';
            groups.forEach(group => {
                const option = document.createElement('option');
                option.value = group;
                option.textContent = group;
                if (rule.bindingType === 'existing' && group === rule.groupName) {
                    option.selected = true;
                }
                groupSelect.appendChild(option);
            });
            
            // è®¾ç½®ç»‘å®šç±»å‹
            const bindingType = rule.bindingType || 'existing';
            document.querySelector(`input[name="binding-type"][value="${bindingType}"]`).checked = true;
            
            // æ ¹æ®ç»‘å®šç±»å‹è®¾ç½®åˆ†ç»„åç§°
            if (bindingType === 'create') {
                document.getElementById('rule-group-name').value = rule.groupName;
            }
            
            // è®¾ç½®åŒ¹é…æ¨¡å¼
            const matchMode = rule.matchMode || rule.rule?.type || 'keywords';
            document.querySelector(`input[name="match-mode"][value="${matchMode}"]`).checked = true;
            
            // è®¾ç½®åŒ¹é…æ¨¡å¼
            document.getElementById('wildcard-pattern').value = rule.rule?.pattern || '';
            
            // å¦‚æœæ˜¯å…³é”®è¯æ¨¡å¼ï¼ŒåŠ è½½å…³é”®è¯
            if (matchMode === 'keywords' && rule.rule) {
                // æ¸…é™¤ç°æœ‰å…³é”®è¯
                includeKeywords = [];
                excludeKeywords = [];
                document.getElementById('include-keywords').innerHTML = '';
                document.getElementById('exclude-keywords').innerHTML = '';
                
                // åŠ è½½åŒ…å«å…³é”®è¯
                if (rule.rule.includeKeywords) {
                    rule.rule.includeKeywords.forEach(keyword => {
                        const container = document.getElementById('include-keywords');
                        addKeywordInput(container, includeKeywords, 'è¾“å…¥åŒ…å«å…³é”®è¯');
                        const inputs = container.querySelectorAll('input');
                        const lastInput = inputs[inputs.length - 1];
                        lastInput.value = keyword;
                        includeKeywords[includeKeywords.length - 1] = keyword;
                    });
                }
                
                // åŠ è½½æ’é™¤å…³é”®è¯
                if (rule.rule.excludeKeywords) {
                    rule.rule.excludeKeywords.forEach(keyword => {
                        const container = document.getElementById('exclude-keywords');
                        addKeywordInput(container, excludeKeywords, 'è¾“å…¥æ’é™¤å…³é”®è¯');
                        const inputs = container.querySelectorAll('input');
                        const lastInput = inputs[inputs.length - 1];
                        lastInput.value = keyword;
                        excludeKeywords[excludeKeywords.length - 1] = keyword;
                    });
                }
            }
            
            // æ ¹æ®ç»‘å®šç±»å‹æ›´æ–°UI
            updateBindingTypeUI();
            
            // æ›´æ–°åŒ¹é…æ¨¡å¼UI
            updateMatchModeUI();
            
            ruleEditorModal.classList.add('show');
        }
    });

    // --- 5. EVENT HANDLERS & LOGIC ---

    // Search listeners
    searchItemsInput.addEventListener('input', (e) => {
        itemFilter = e.target.value;
        mainCurrentPage = 1;
        renderItems();
    });
    searchGroupsInput.addEventListener('input', (e) => {
        groupFilter = e.target.value;
        renderGroups();
    });

    // Main pagination clicks
    paginationContainer.addEventListener('click', (e) => {
        if (e.target.id === 'prev-page' && mainCurrentPage > 1) {
            mainCurrentPage--;
            renderItems();
        }
        if (e.target.id === 'next-page' && !e.target.disabled) {
            mainCurrentPage++;
            renderItems();
        }
    });

    // "Select All" logic
    selectAllCheckbox.addEventListener('change', () => {
        itemsContainer.querySelectorAll('.item-checkbox').forEach(c => c.checked = selectAllCheckbox.checked);
    });
    const updateSelectAllCheckbox = () => {
        const checkboxes = itemsContainer.querySelectorAll('.item-checkbox');
        selectAllCheckbox.checked = checkboxes.length > 0 && Array.from(checkboxes).every(c => c.checked);
    }
    itemsContainer.addEventListener('change', (e) => {
        if (e.target.classList.contains('item-checkbox')) updateSelectAllCheckbox();
    });

    // Group selection functionality
    const updateSelectAllGroupsCheckbox = () => {
        const groupCheckboxes = groupsTableBody.querySelectorAll('.group-checkbox');
        selectAllGroupsCheckbox.checked = groupCheckboxes.length > 0 && Array.from(groupCheckboxes).every(c => c.checked);
    };

    selectAllGroupsCheckbox.addEventListener('change', () => {
        const groupCheckboxes = groupsTableBody.querySelectorAll('.group-checkbox');
        groupCheckboxes.forEach(checkbox => {
            checkbox.checked = selectAllGroupsCheckbox.checked;
        });
    });

    groupsContainer.addEventListener('change', (e) => {
        if (e.target.classList.contains('group-checkbox')) updateSelectAllGroupsCheckbox();
    });

    // Tooltip functionality for auto badges
    let currentTooltip = null;

    const showTooltip = (element, content) => {
        hideTooltip();

        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip show';
        tooltip.innerHTML = content;
        document.body.appendChild(tooltip);

        const rect = element.getBoundingClientRect();
        const tooltipRect = tooltip.getBoundingClientRect();

        tooltip.style.left = (rect.left + rect.width / 2 - tooltipRect.width / 2) + 'px';
        tooltip.style.top = (rect.top - tooltipRect.height - 8) + 'px';

        currentTooltip = tooltip;
    };

    const hideTooltip = () => {
        if (currentTooltip) {
            currentTooltip.remove();
            currentTooltip = null;
        }
    };

    // Auto badge hover events
    groupsContainer.addEventListener('mouseenter', (e) => {
        if (e.target.classList.contains('auto-badge')) {
            const ruleId = e.target.dataset.ruleId;
            const rule = groupRules.find(r => r.id === ruleId);

            if (rule) {
                let ruleDetails = '';
                switch (rule.rule.type) {
                    case 'wildcard':
                        ruleDetails = `é€šé…ç¬¦åŒ¹é…: ${rule.rule.pattern}`;
                        break;
                    case 'regex':
                        ruleDetails = `æ­£åˆ™è¡¨è¾¾å¼: ${rule.rule.pattern}`;
                        break;
                    case 'exact':
                        ruleDetails = `ç²¾ç¡®åŒ¹é…: ${rule.rule.pattern}`;
                        break;
                    case 'keywords':
                        const includes = rule.rule.includeKeywords?.length ?
                            `åŒ…å«: ${rule.rule.includeKeywords.join(', ')}` : '';
                        const excludes = rule.rule.excludeKeywords?.length ?
                            `æ’é™¤: ${rule.rule.excludeKeywords.join(', ')}` : '';
                        ruleDetails = [includes, excludes].filter(Boolean).join('<br>');
                        break;
                    default:
                        ruleDetails = 'æœªçŸ¥è§„åˆ™ç±»å‹';
                }

                const tooltipContent = `
                    <strong>${rule.name}</strong><br>
                    ä¼˜å…ˆçº§: ${rule.priority}<br>
                    ${ruleDetails}<br>
                    åŒ¹é…æ•°é‡: ${rule.stats?.matchCount || 0}é¡¹
                `;

                showTooltip(e.target, tooltipContent);
            }
        }
    }, true);

    groupsContainer.addEventListener('mouseleave', (e) => {
        if (e.target.classList.contains('auto-badge')) {
            hideTooltip();
        }
    }, true);

    // Rule search functionality
    searchRulesInput.addEventListener('input', (e) => {
        ruleFilter = e.target.value.toLowerCase();
        renderRuleListInPanel();
    });

    // Rule selection functionality
    selectAllRulesCheckbox.addEventListener('change', () => {
        const ruleCheckboxes = ruleTableBody.querySelectorAll('.rule-checkbox');
        ruleCheckboxes.forEach(checkbox => {
            checkbox.checked = selectAllRulesCheckbox.checked;
        });
        updateBatchButtonsState();
    });

    // Right panel event delegation for new table structure
    groupsContainer.addEventListener('click', (e) => {
        const tableRow = e.target.closest('.table-row');
        if (!tableRow) return;
        const groupName = tableRow.dataset.groupName;

        // Add selected items to this group
        if (e.target.classList.contains('add-to-group')) {
            const selectedCheckboxes = itemsContainer.querySelectorAll('.item-checkbox:checked');
            if (selectedCheckboxes.length === 0) {
                alert('è¯·å…ˆåœ¨å·¦ä¾§å‹¾é€‰è¦åˆ†ç»„çš„é¡¹ï¼');
                return;
            }
            selectedCheckboxes.forEach(checkbox => {
                const item = allItems.find(i => i.id === parseInt(checkbox.dataset.id));
                if (item) {
                    item.group = groupName;
                    item.isAutoGrouped = false; // Manual grouping overrides auto
                }
            });
            alert(`å·²å°† ${selectedCheckboxes.length} ä¸ªé¡¹ç›®ç§»åŠ¨åˆ° "${groupName}" åˆ†ç»„ã€‚`);
            renderAll();
        }



        // Remove an item from this group
        if (e.target.classList.contains('delete-item')) {
            const itemId = parseInt(e.target.dataset.itemId);
            const item = allItems.find(i => i.id === itemId);
            if (item) {
                item.group = 'å¾…åˆ†ç»„';
                item.isAutoGrouped = false;
                // Reset pagination for the group if it becomes empty on the current page
                const itemsLeftInGroup = allItems.filter(i => i.group === groupName);
                const totalPages = Math.ceil(itemsLeftInGroup.length / nestedItemsPerPage);
                if (groupPagination[groupName] > totalPages && totalPages > 0) {
                    groupPagination[groupName] = totalPages;
                }
            }
            renderAll();
        }

        // Nested pagination
        const currentPage = groupPagination[groupName] || 1;
        if (e.target.classList.contains('nested-prev-page') && currentPage > 1) {
            groupPagination[groupName] = currentPage - 1;
            renderGroups();
        }
        if (e.target.classList.contains('nested-next-page') && !e.target.disabled) {
            groupPagination[groupName] = currentPage + 1;
            renderGroups();
        }
    });

    // "New Group" button
    btnNewGroup.addEventListener('click', () => {
        const newGroupName = prompt('è¯·è¾“å…¥æ–°çš„åˆ†ç»„åç§°:');
        if (newGroupName && newGroupName.trim() && !groups.includes(newGroupName.trim())) {
            groups.push(newGroupName.trim());
            groups.sort();
            renderGroups();
        } else if (newGroupName) {
            alert('åˆ†ç»„åç§°å·²å­˜åœ¨æˆ–æ— æ•ˆã€‚');
        }
    });

    // "Match Groups" button - Auto match items to selected groups
    btnMatchGroups.addEventListener('click', () => {
        // Get selected groups
        const selectedGroupCheckboxes = document.querySelectorAll('.group-checkbox:checked');
        if (selectedGroupCheckboxes.length === 0) {
            alert('è¯·å…ˆé€‰æ‹©è¦è¿›è¡ŒåŒ¹é…çš„åˆ†ç»„');
            return;
        }

        const selectedGroupNames = Array.from(selectedGroupCheckboxes).map(cb => cb.dataset.group);
        let totalMatched = 0;
        let matchResults = [];

        // Process each selected group
        selectedGroupNames.forEach(groupName => {
            // Find enabled rule for this group
            const matchingRule = groupRules.find(rule =>
                rule.enabled && rule.groupName === groupName
            );

            if (!matchingRule) {
                matchResults.push(`${groupName}: æœªç»‘å®šå¯ç”¨çš„åŒ¹é…è§„åˆ™`);
                return;
            }

            // Find unassigned items that match this rule
            const unassignedItems = allItems.filter(item => item.group === 'å¾…åˆ†ç»„');
            let groupMatched = 0;

            unassignedItems.forEach(item => {
                if (matchRule(item.name, matchingRule.rule || matchingRule)) {
                    item.group = groupName;
                    item.isAutoGrouped = true;
                    item.appliedRuleId = matchingRule.id;
                    groupMatched++;
                    totalMatched++;
                }
            });

            // Update rule stats
            matchingRule.stats.matchCount = (matchingRule.stats.matchCount || 0) + groupMatched;
            if (groupMatched > 0) {
                matchingRule.stats.lastMatched = new Date().toISOString();
            }

            matchResults.push(`${groupName}: åŒ¹é…äº† ${groupMatched} é¡¹`);
        });

        // Show results
        const resultMessage = `åŒ¹é…å®Œæˆï¼\n\n${matchResults.join('\n')}\n\næ€»è®¡åŒ¹é…: ${totalMatched} é¡¹`;
        alert(resultMessage);

        // Refresh all displays
        renderAll();

        // Clear group selections
        selectedGroupCheckboxes.forEach(cb => cb.checked = false);
        updateSelectAllGroupsCheckbox();
    });

    // Add tooltip for match button
    btnMatchGroups.addEventListener('mouseenter', () => {
        const tooltipContent = 'ç‚¹å‡»åå·²ç»‘å®šè§„åˆ™çš„åˆ†ç»„å°†ä¼šè‡ªåŠ¨å°†ç¬¦åˆåŒ¹é…è§„åˆ™ï¼Œä¸”æœªåˆ†ç»„çš„ç»´åº¦å€¼åŠ å…¥å¯¹åº”åˆ†ç»„';
        showTooltip(btnMatchGroups, tooltipContent);
    });

    btnMatchGroups.addEventListener('mouseleave', () => {
        hideTooltip();
    });

    // Rule management events - æ–°å»ºè§„åˆ™æŒ‰é’®ï¼ˆé¦–é¡µï¼‰
    document.getElementById('btn-new-rule-main').addEventListener('click', (e) => {
        e.stopPropagation();
        editingRuleId = null;
        document.getElementById('rule-editor-title').textContent = 'æ–°å»ºåˆ†ç»„è§„åˆ™';
        document.getElementById('rule-editor-form').reset();
        
        // Reset keywords
        includeKeywords = [];
        excludeKeywords = [];
        document.getElementById('include-keywords').innerHTML = '';
        document.getElementById('exclude-keywords').innerHTML = '';

        // Reset priority configuration
        priorityConfig = { type: 'lowest', afterRuleId: null };
        document.getElementById('priority-select').value = 'lowest';
        document.getElementById('priority-section').style.display = 'block';

        // Update priority options when modal opens
        updatePriorityOptions();

        // Populate existing groups dropdown
        const groupSelect = document.getElementById('rule-group-select');
        groupSelect.innerHTML = '<option value="">è¯·é€‰æ‹©åˆ†ç»„</option>';
        groups.forEach(group => {
            const option = document.createElement('option');
            option.value = group;
            option.textContent = group;
            groupSelect.appendChild(option);
        });
        
        // Show/hide sections based on binding type
        updateBindingTypeUI();
        
        // Update match mode sections
        updateMatchModeUI();
        
        ruleEditorModal.classList.add('show');
    });

    // Close modals
    document.getElementById('close-rule-modal').addEventListener('click', () => {
        ruleModal.classList.remove('show');
    });
    document.getElementById('cancel-rule-modal').addEventListener('click', () => {
        ruleModal.classList.remove('show');
    });
    document.getElementById('save-rule-modal').addEventListener('click', () => {
        applyRules();
        ruleModal.classList.remove('show');
    });

    // New rule button
    btnNewRule.addEventListener('click', () => {
        editingRuleId = null;
        document.getElementById('rule-editor-title').textContent = 'æ–°å»ºåˆ†ç»„è§„åˆ™';
        document.getElementById('rule-editor-form').reset();
        
        // Reset keywords
        includeKeywords = [];
        excludeKeywords = [];
        document.getElementById('include-keywords').innerHTML = '';
        document.getElementById('exclude-keywords').innerHTML = '';

        // Reset priority configuration
        priorityConfig = { type: 'lowest', afterRuleId: null };
        document.getElementById('priority-select').value = 'lowest';
        document.getElementById('priority-section').style.display = 'block';

        // Update priority options when modal opens
        updatePriorityOptions();

        // Populate existing groups dropdown
        const groupSelect = document.getElementById('rule-group-select');
        groupSelect.innerHTML = '<option value="">è¯·é€‰æ‹©åˆ†ç»„</option>';
        groups.forEach(group => {
            const option = document.createElement('option');
            option.value = group;
            option.textContent = group;
            groupSelect.appendChild(option);
        });
        
        // Show/hide sections based on binding type
        updateBindingTypeUI();
        
        // Update match mode sections
        updateMatchModeUI();
        
        ruleEditorModal.classList.add('show');
    });
    
    // Binding type radio button change handler
    document.querySelectorAll('input[name="binding-type"]').forEach(radio => {
        radio.addEventListener('change', updateBindingTypeUI);
    });
    
    function updateBindingTypeUI() {
        const bindingType = document.querySelector('input[name="binding-type"]:checked').value;
        const existingGroupSection = document.getElementById('existing-group-section');
        const newGroupSection = document.getElementById('new-group-section');
        
        if (bindingType === 'existing') {
            existingGroupSection.style.display = 'block';
            newGroupSection.style.display = 'none';
        } else {
            existingGroupSection.style.display = 'none';
            newGroupSection.style.display = 'block';
        }
    }

    // Rule editor modal events
    document.getElementById('close-rule-editor').addEventListener('click', () => {
        ruleEditorModal.classList.remove('show');
    });
    document.getElementById('cancel-rule-editor').addEventListener('click', () => {
        ruleEditorModal.classList.remove('show');
    });

    // Save rule with enhanced data structure
    document.getElementById('save-rule-editor').addEventListener('click', () => {
        const bindingType = document.querySelector('input[name="binding-type"]:checked').value;
        const matchMode = document.querySelector('input[name="match-mode"]:checked').value;
        
        let groupName = '';
        if (bindingType === 'existing') {
            groupName = document.getElementById('rule-group-select').value;
            if (!groupName) {
                alert('è¯·é€‰æ‹©ä¸€ä¸ªåˆ†ç»„');
                return;
            }
        } else {
            groupName = document.getElementById('rule-group-name').value.trim();
            if (!groupName) {
                alert('è¯·è¾“å…¥æ–°åˆ†ç»„åç§°');
                return;
            }
        }

        // Build rule object based on match mode
        let ruleObj = { type: matchMode };
        
        if (matchMode === 'wildcard' || matchMode === 'regex') {
            const pattern = document.getElementById('wildcard-pattern').value.trim();
            if (!pattern) {
                alert('è¯·è¾“å…¥åŒ¹é…è§„åˆ™');
                return;
            }
            ruleObj.pattern = pattern;
        } else if (matchMode === 'keywords') {
            // Collect keywords from UI
            const validIncludeKeywords = includeKeywords.filter(k => k.trim() !== '');
            const validExcludeKeywords = excludeKeywords.filter(k => k.trim() !== '');
            
            if (validIncludeKeywords.length === 0 && validExcludeKeywords.length === 0) {
                alert('è¯·è‡³å°‘æ·»åŠ ä¸€ä¸ªåŒ…å«å…³é”®è¯æˆ–æ’é™¤å…³é”®è¯');
                return;
            }
            
            ruleObj.includeKeywords = validIncludeKeywords;
            ruleObj.excludeKeywords = validExcludeKeywords;
        }

        // Calculate priority based on priority configuration
        let newPriority;
        if (editingRuleId) {
            // Keep existing priority when editing
            newPriority = groupRules.find(r => r.id === editingRuleId).priority;
        } else {
            // Calculate new priority based on priority config
            newPriority = calculateNewRulePriority();
        }

        const ruleData = {
            id: editingRuleId,
            name: `${groupName} - ${matchMode}`,
            groupName: groupName,
            bindingType: bindingType,
            matchMode: matchMode,
            rule: ruleObj,
            priority: newPriority,
            enabled: true
        };

        const newRule = createRule(ruleData);

        if (editingRuleId) {
            const index = groupRules.findIndex(r => r.id === editingRuleId);
            groupRules[index] = newRule;
        } else {
            // Insert new rule and adjust priorities of other rules
            insertNewRuleWithPriority(newRule);
        }

        // Save to localStorage
        saveRulesToStorage();
        
        renderRuleList();
        ruleEditorModal.classList.remove('show');
    });

    // Rule list events
    ruleList.addEventListener('click', (e) => {
        const ruleItem = e.target.closest('.rule-item');
        if (!ruleItem) return;
        
        const ruleId = ruleItem.dataset.ruleId;
        const rule = groupRules.find(r => r.id === ruleId);

        // Edit rule with enhanced data
        if (e.target.classList.contains('edit-rule')) {
            editingRuleId = ruleId;
            document.getElementById('rule-editor-title').textContent = 'ç¼–è¾‘åˆ†ç»„è§„åˆ™';
            
            // Populate existing groups dropdown
            const groupSelect = document.getElementById('rule-group-select');
            groupSelect.innerHTML = '<option value="">è¯·é€‰æ‹©åˆ†ç»„</option>';
            groups.forEach(group => {
                const option = document.createElement('option');
                option.value = group;
                option.textContent = group;
                if (rule.bindingType === 'existing' && group === rule.groupName) {
                    option.selected = true;
                }
                groupSelect.appendChild(option);
            });
            
            // Set binding type
            const bindingType = rule.bindingType || 'existing';
            document.querySelector(`input[name="binding-type"][value="${bindingType}"]`).checked = true;
            
            // Set group name based on binding type
            if (bindingType === 'create') {
                document.getElementById('rule-group-name').value = rule.groupName;
            }
            
            // Set match mode
            const matchMode = rule.matchMode || rule.rule?.type || 'keywords';
            document.querySelector(`input[name="match-mode"][value="${matchMode}"]`).checked = true;
            
            // Set pattern
            document.getElementById('wildcard-pattern').value = rule.rule?.pattern || '';
            
            // Load keywords if in keywords mode
            if (matchMode === 'keywords' && rule.rule) {
                // Clear existing keywords
                includeKeywords = [];
                excludeKeywords = [];
                document.getElementById('include-keywords').innerHTML = '';
                document.getElementById('exclude-keywords').innerHTML = '';
                
                // Load include keywords
                if (rule.rule.includeKeywords) {
                    rule.rule.includeKeywords.forEach(keyword => {
                        const container = document.getElementById('include-keywords');
                        addKeywordInput(container, includeKeywords, 'è¾“å…¥åŒ…å«å…³é”®è¯');
                        const inputs = container.querySelectorAll('input');
                        const lastInput = inputs[inputs.length - 1];
                        lastInput.value = keyword;
                        includeKeywords[includeKeywords.length - 1] = keyword;
                    });
                }
                
                // Load exclude keywords
                if (rule.rule.excludeKeywords) {
                    rule.rule.excludeKeywords.forEach(keyword => {
                        const container = document.getElementById('exclude-keywords');
                        addKeywordInput(container, excludeKeywords, 'è¾“å…¥æ’é™¤å…³é”®è¯');
                        const inputs = container.querySelectorAll('input');
                        const lastInput = inputs[inputs.length - 1];
                        lastInput.value = keyword;
                        excludeKeywords[excludeKeywords.length - 1] = keyword;
                    });
                }
            }
            
            // Update UI based on binding type
            updateBindingTypeUI();
            
            // Update match mode sections
            updateMatchModeUI();
            
            ruleEditorModal.classList.add('show');
        }

        // Delete rule
        if (e.target.classList.contains('delete-rule')) {
            if (confirm(`ç¡®å®šè¦åˆ é™¤è§„åˆ™"${rule.groupName}"å—ï¼Ÿ`)) {
                groupRules = groupRules.filter(r => r.id !== ruleId);
                // Reorder priorities
                groupRules.forEach((r, index) => {
                    r.priority = index + 1;
                });
                renderRuleList();
            }
        }

        // Toggle enabled
        if (e.target.classList.contains('rule-checkbox')) {
            rule.enabled = e.target.checked;
            updateRuleCount();
        }
    });

    // Match mode toggle with enhanced support
    document.querySelectorAll('input[name="match-mode"]').forEach(radio => {
        radio.addEventListener('change', updateMatchModeUI);
    });
    
    function updateMatchModeUI() {
        const matchMode = document.querySelector('input[name="match-mode"]:checked').value;
        const wildcardSection = document.getElementById('wildcard-section');
        const keywordsSection = document.getElementById('keywords-section');
        const patternLabel = wildcardSection.querySelector('.form-label');
        const patternInput = document.getElementById('wildcard-pattern');
        const inputHint = document.getElementById('wildcard-hint');
        const wildcardHelpPanel = document.getElementById('wildcard-help-panel');
        const regexHelpPanel = document.getElementById('regex-help-panel');

        // Reset sections
        wildcardSection.style.display = 'none';
        keywordsSection.style.display = 'none';
        wildcardHelpPanel.style.display = 'none';
        regexHelpPanel.style.display = 'none';

        switch (matchMode) {
            case 'keywords':
                keywordsSection.style.display = 'block';
                break;

            case 'wildcard':
                wildcardSection.style.display = 'block';
                patternLabel.innerHTML = 'åŒ¹é…è§„åˆ™<span class="required">*</span>';
                patternInput.placeholder = 'ä¾‹å¦‚ï¼šå¤´æ¡*';
                inputHint.innerHTML = 'ä½¿ç”¨ * ä»£è¡¨ä»»æ„å­—ç¬¦ï¼Œå¦‚ "å¤´æ¡*" åŒ¹é…æ‰€æœ‰ä»¥"å¤´æ¡"å¼€å¤´çš„ç»´åº¦å€¼ <a href="javascript:void(0)" class="help-link" id="wildcard-help-btn">è¯¦ç»†è§„åˆ™</a>';

                // Setup help button for wildcard
                document.getElementById('wildcard-help-btn').onclick = function() {
                    wildcardHelpPanel.style.display = 'block';
                };
                document.getElementById('close-wildcard-help').onclick = function() {
                    wildcardHelpPanel.style.display = 'none';
                };
                break;

            case 'regex':
                wildcardSection.style.display = 'block';
                patternLabel.innerHTML = 'æ­£åˆ™è¡¨è¾¾å¼<span class="required">*</span>';
                patternInput.placeholder = 'ä¾‹å¦‚ï¼š^å¤´æ¡.*';
                inputHint.innerHTML = 'ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼è¿›è¡Œç²¾ç¡®åŒ¹é…ï¼Œå¦‚ "^å¤´æ¡.*" åŒ¹é…ä»¥"å¤´æ¡"å¼€å¤´çš„ç»´åº¦å€¼ <a href="javascript:void(0)" class="help-link" id="regex-help-btn">è¯¦ç»†è§„åˆ™</a>';

                // Setup help button for regex
                document.getElementById('regex-help-btn').onclick = function() {
                    regexHelpPanel.style.display = 'block';
                };
                document.getElementById('close-regex-help').onclick = function() {
                    regexHelpPanel.style.display = 'none';
                };
                break;
        }

        // Trigger preview update
        updatePreview();
    }

    // Keyword management functions
    let includeKeywords = [];
    let excludeKeywords = [];

    // Priority configuration state
    let priorityConfig = {
        type: 'lowest', // 'highest', 'after', 'lowest'
        afterRuleId: null
    };

    // Update priority section (now always visible, just update options)
    function updatePrioritySection() {
        updatePriorityOptions();
    }

    // Update priority options based on existing rules
    function updatePriorityOptions() {
        const prioritySelect = document.getElementById('priority-select');

        // Store current selection
        const currentValue = prioritySelect.value;

        // Clear existing options
        prioritySelect.innerHTML = '';

        // Add "æœ€é«˜ä¼˜å…ˆçº§" option
        const highestOption = document.createElement('option');
        highestOption.value = 'highest';
        highestOption.textContent = 'æœ€é«˜ä¼˜å…ˆçº§';
        prioritySelect.appendChild(highestOption);

        // Get existing rules (exclude current editing rule if any)
        const existingRules = groupRules.filter(rule =>
            !rule.isSystemRule &&
            rule.enabled &&
            rule.id !== editingRuleId
        ).sort((a, b) => a.priority - b.priority);

        // Add existing rules as "after" options
        existingRules.forEach(rule => {
            const option = document.createElement('option');
            option.value = rule.id;
            // Extract rule pattern for display
            let rulePattern = '';
            if (rule.rule.type === 'keywords') {
                const includes = rule.rule.includeKeywords || [];
                const excludes = rule.rule.excludeKeywords || [];
                rulePattern = includes.join(', ');
                if (excludes.length > 0) {
                    rulePattern += ` (æ’é™¤: ${excludes.join(', ')})`;
                }
            } else {
                rulePattern = rule.rule.pattern || '';
            }
            option.textContent = `<${rulePattern}>ä¹‹å`;
            prioritySelect.appendChild(option);
        });

        // Add "æœ€ä½ä¼˜å…ˆçº§" option
        const lowestOption = document.createElement('option');
        lowestOption.value = 'lowest';
        lowestOption.textContent = 'æœ€ä½ä¼˜å…ˆçº§';
        prioritySelect.appendChild(lowestOption);

        // Restore selection or default to "lowest"
        if (currentValue && prioritySelect.querySelector(`option[value="${currentValue}"]`)) {
            prioritySelect.value = currentValue;
        } else {
            prioritySelect.value = 'lowest';
            priorityConfig.type = 'lowest';
            priorityConfig.afterRuleId = null;
        }
    }

    const addKeywordInput = (container, keywords, placeholder) => {
        const keywordDiv = document.createElement('div');
        keywordDiv.className = 'keyword-input-group';
        keywordDiv.style.cssText = 'display: flex; align-items: center; margin-bottom: 8px; gap: 8px;';
        
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'form-input';
        input.placeholder = placeholder;
        input.style.flex = '1';
        
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'btn btn-default btn-sm';
        removeBtn.textContent = 'åˆ é™¤';
        removeBtn.style.flexShrink = '0';
        
        removeBtn.addEventListener('click', () => {
            const index = Array.from(container.children).indexOf(keywordDiv);
            keywords.splice(index, 1);
            keywordDiv.remove();
            updatePreview();
        });

        input.addEventListener('input', () => {
            const index = Array.from(container.children).indexOf(keywordDiv);
            keywords[index] = input.value.trim();
            clearTimeout(previewTimeout);
            previewTimeout = setTimeout(() => {
                updatePreview();
            }, 500);
        });
        
        keywordDiv.appendChild(input);
        keywordDiv.appendChild(removeBtn);
        container.appendChild(keywordDiv);
        
        keywords.push('');
        input.focus();
    };

    // Add keyword buttons
    document.getElementById('add-include-keyword').addEventListener('click', () => {
        const container = document.getElementById('include-keywords');
        addKeywordInput(container, includeKeywords, 'è¾“å…¥åŒ…å«å…³é”®è¯');
    });

    document.getElementById('add-exclude-keyword').addEventListener('click', () => {
        const container = document.getElementById('exclude-keywords');
        addKeywordInput(container, excludeKeywords, 'è¾“å…¥æ’é™¤å…³é”®è¯');
    });

    // Priority configuration event listeners
    document.getElementById('priority-select').addEventListener('change', (e) => {
        const selectedValue = e.target.value;

        if (selectedValue === 'highest') {
            priorityConfig.type = 'highest';
            priorityConfig.afterRuleId = null;
        } else if (selectedValue === 'lowest') {
            priorityConfig.type = 'lowest';
            priorityConfig.afterRuleId = null;
        } else {
            // It's a rule ID, meaning "after" this rule
            priorityConfig.type = 'after';
            priorityConfig.afterRuleId = selectedValue;
        }

        // Update preview when priority changes
        updatePreview();
    });

    // Real-time preview
    let previewTimeout;
    document.getElementById('wildcard-pattern').addEventListener('input', (e) => {
        clearTimeout(previewTimeout);
        previewTimeout = setTimeout(() => {
            updatePreview();
        }, 500);
    });

    const updatePreview = () => {
        // Check if matching rule is configured
        const matchMode = document.querySelector('input[name="match-mode"]:checked').value;
        let isRuleConfigured = false;

        if (matchMode === 'keywords') {
            const validIncludeKeywords = includeKeywords.filter(k => k.trim() !== '');
            const validExcludeKeywords = excludeKeywords.filter(k => k.trim() !== '');
            isRuleConfigured = validIncludeKeywords.length > 0 || validExcludeKeywords.length > 0;
        } else {
            const pattern = document.getElementById('wildcard-pattern').value.trim();
            isRuleConfigured = pattern !== '';
        }

        // If matching rule is not configured, show simple preview
        if (!isRuleConfigured) {
            showSimplePreview();
            return;
        }

        // Show enhanced preview with all rules simulation
        showEnhancedPreview();
    };

    // Simple preview for when priority is not configured
    const showSimplePreview = () => {
        const matchMode = document.querySelector('input[name="match-mode"]:checked').value;
        const previewStats = document.getElementById('preview-stats');
        const previewList = document.getElementById('preview-list');
        const previewConflicts = document.getElementById('preview-conflicts');
        const previewMore = document.getElementById('preview-more');

        // Hide conflicts section
        previewConflicts.style.display = 'none';

        // Build test rule based on match mode
        let testRule = { type: matchMode };

        if (matchMode === 'keywords') {
            const validIncludeKeywords = includeKeywords.filter(k => k.trim() !== '');
            const validExcludeKeywords = excludeKeywords.filter(k => k.trim() !== '');

            testRule.includeKeywords = validIncludeKeywords;
            testRule.excludeKeywords = validExcludeKeywords;

            if (validIncludeKeywords.length === 0 && validExcludeKeywords.length === 0) {
                previewStats.innerHTML = '<div class="stat-item">è¯·æ·»åŠ å…³é”®è¯ä»¥æŸ¥çœ‹åŒ¹é…ç»“æœ</div>';
                previewList.innerHTML = '';
                previewMore.style.display = 'none';
                return;
            }
        } else {
            const pattern = document.getElementById('wildcard-pattern').value.trim();
            if (!pattern) {
                previewStats.innerHTML = '<div class="stat-item">è¯·è¾“å…¥åŒ¹é…è§„åˆ™ä»¥æŸ¥çœ‹é¢„è§ˆ</div>';
                previewList.innerHTML = '';
                previewMore.style.display = 'none';
                return;
            }
            testRule.pattern = pattern;
        }

        // Find matches
        const matches = allItems.filter(item =>
            item.group === 'å¾…åˆ†ç»„' && matchRule(item.name, testRule)
        );

        // Update stats
        previewStats.innerHTML = `<div class="stat-item">å½“å‰è§„åˆ™å°†åŒ¹é… <strong>${matches.length}</strong> ä¸ªç»´åº¦å€¼</div>`;

        // Update list
        previewList.innerHTML = '';
        if (matches.length === 0) {
            previewList.innerHTML = '<div style="color: #999;">æ²¡æœ‰åŒ¹é…çš„ç»´åº¦å€¼</div>';
        } else {
            const displayCount = Math.min(matches.length, 5);
            for (let i = 0; i < displayCount; i++) {
                const div = document.createElement('div');
                div.className = 'preview-item';
                div.textContent = matches[i].name;
                previewList.appendChild(div);
            }
        }

        previewMore.style.display = matches.length > 5 ? 'block' : 'none';
    };

    // Enhanced preview with all rules simulation
    const showEnhancedPreview = () => {
        const matchMode = document.querySelector('input[name="match-mode"]:checked').value;
        const bindingType = document.querySelector('input[name="binding-type"]:checked').value;
        const previewStats = document.getElementById('preview-stats');
        const previewList = document.getElementById('preview-list');
        const previewConflicts = document.getElementById('preview-conflicts');
        const previewMore = document.getElementById('preview-more');

        // Get group name
        let groupName;
        if (bindingType === 'existing') {
            groupName = document.getElementById('rule-group-select').value;
        } else {
            groupName = document.getElementById('rule-group-name').value.trim();
        }

        if (!groupName) {
            previewStats.innerHTML = '<div class="stat-item">è¯·å…ˆé€‰æ‹©æˆ–è¾“å…¥åˆ†ç»„åç§°</div>';
            previewList.innerHTML = '';
            previewConflicts.style.display = 'none';
            previewMore.style.display = 'none';
            return;
        }

        // Build new rule
        let newRule = { type: matchMode };

        if (matchMode === 'keywords') {
            const validIncludeKeywords = includeKeywords.filter(k => k.trim() !== '');
            const validExcludeKeywords = excludeKeywords.filter(k => k.trim() !== '');

            if (validIncludeKeywords.length === 0 && validExcludeKeywords.length === 0) {
                previewStats.innerHTML = '<div class="stat-item">è¯·æ·»åŠ å…³é”®è¯ä»¥æŸ¥çœ‹åŒ¹é…ç»“æœ</div>';
                previewList.innerHTML = '';
                previewConflicts.style.display = 'none';
                previewMore.style.display = 'none';
                return;
            }

            newRule.includeKeywords = validIncludeKeywords;
            newRule.excludeKeywords = validExcludeKeywords;
        } else {
            const pattern = document.getElementById('wildcard-pattern').value.trim();
            if (!pattern) {
                previewStats.innerHTML = '<div class="stat-item">è¯·è¾“å…¥åŒ¹é…è§„åˆ™ä»¥æŸ¥çœ‹é¢„è§ˆ</div>';
                previewList.innerHTML = '';
                previewConflicts.style.display = 'none';
                previewMore.style.display = 'none';
                return;
            }
            newRule.pattern = pattern;
        }

        // Simulate rules with new rule included
        const simulationResult = simulateRulesWithNewRule(newRule, groupName);

        // Update stats
        const newRuleMatches = simulationResult.newRuleMatches;
        const conflicts = simulationResult.conflicts;
        const totalProcessed = simulationResult.totalProcessed;

        let statsHtml = `<div class="stat-item">æ–°è§„åˆ™å°†åŒ¹é… <strong>${newRuleMatches.length}</strong> ä¸ªç»´åº¦å€¼</div>`;
        statsHtml += `<div class="stat-item">æ€»å…±å¤„ç† <strong>${totalProcessed}</strong> ä¸ªå¾…åˆ†ç»„ç»´åº¦å€¼</div>`;

        if (conflicts.length > 0) {
            statsHtml += `<div class="stat-item" style="color: #fa8c16;">æ£€æµ‹åˆ° <strong>${conflicts.length}</strong> ä¸ªæ½œåœ¨å†²çª</div>`;
        }

        previewStats.innerHTML = statsHtml;

        // Update list - show new rule matches
        previewList.innerHTML = '';
        if (newRuleMatches.length === 0) {
            previewList.innerHTML = '<div style="color: #999;">æ–°è§„åˆ™æ²¡æœ‰åŒ¹é…çš„ç»´åº¦å€¼</div>';
        } else {
            const displayCount = Math.min(newRuleMatches.length, 5);
            for (let i = 0; i < displayCount; i++) {
                const div = document.createElement('div');
                div.className = 'preview-item';
                div.textContent = `${newRuleMatches[i].name} â†’ ${groupName}`;
                previewList.appendChild(div);
            }
        }

        previewMore.style.display = newRuleMatches.length > 5 ? 'block' : 'none';

        // Update conflicts
        if (conflicts.length > 0) {
            previewConflicts.style.display = 'block';
            let conflictsHtml = '<div class="conflict-warning">âš ï¸ æ£€æµ‹åˆ°ä»¥ä¸‹å†²çªæˆ–é‡å ï¼š</div>';

            conflicts.forEach(conflict => {
                conflictsHtml += `<div class="conflict-item">${conflict.itemName}: ${conflict.description}</div>`;
            });

            previewConflicts.innerHTML = conflictsHtml;
        } else {
            previewConflicts.style.display = 'none';
        }
    };

    // Simulate rules execution with new rule included
    const simulateRulesWithNewRule = (newRule, groupName) => {
        // Create temporary rule object
        const tempRule = {
            id: 'temp_new_rule',
            name: `${groupName} - æ–°è§„åˆ™`,
            groupName: groupName,
            rule: newRule,
            enabled: true,
            isSystemRule: false,
            priority: calculateNewRulePriority()
        };

        // Create temporary rules list with new rule inserted
        const tempRules = [...groupRules.filter(r => !r.isSystemRule && r.enabled && r.id !== editingRuleId)];

        // Insert new rule at correct position based on priority config
        insertRuleAtPriority(tempRules, tempRule);

        // Sort by priority
        tempRules.sort((a, b) => a.priority - b.priority);

        // Simulate rule execution
        const result = {
            newRuleMatches: [],
            conflicts: [],
            totalProcessed: 0,
            groupingResults: new Map() // itemId -> { groupName, ruleId, conflictingRules }
        };

        // Get all unassigned items
        const unassignedItems = allItems.filter(item => item.group === 'å¾…åˆ†ç»„');
        result.totalProcessed = unassignedItems.length;

        // Apply rules in priority order
        unassignedItems.forEach(item => {
            const matchingRules = [];

            // Find all matching rules
            for (const rule of tempRules) {
                if (matchRule(item.name, rule.rule)) {
                    matchingRules.push(rule);
                }
            }

            if (matchingRules.length > 0) {
                // Use first matching rule (highest priority)
                const winningRule = matchingRules[0];
                result.groupingResults.set(item.id, {
                    groupName: winningRule.groupName,
                    ruleId: winningRule.id,
                    conflictingRules: matchingRules.slice(1)
                });

                // Track if new rule matched this item
                if (winningRule.id === 'temp_new_rule') {
                    result.newRuleMatches.push(item);
                }

                // Check for conflicts
                if (matchingRules.length > 1) {
                    const conflictingRuleNames = matchingRules.slice(1).map(r => r.groupName);
                    let description;

                    if (winningRule.id === 'temp_new_rule') {
                        description = `æ–°è§„åˆ™ä¼˜å…ˆçº§æ›´é«˜ï¼Œå°†è¦†ç›–è§„åˆ™: ${conflictingRuleNames.join(', ')}`;
                    } else {
                        const hasNewRule = matchingRules.some(r => r.id === 'temp_new_rule');
                        if (hasNewRule) {
                            description = `ç°æœ‰è§„åˆ™"${winningRule.groupName}"ä¼˜å…ˆçº§æ›´é«˜ï¼Œæ–°è§„åˆ™ä¸ä¼šåŒ¹é…æ­¤é¡¹`;
                        } else {
                            description = `å¤šä¸ªç°æœ‰è§„åˆ™åŒ¹é…ï¼Œä½¿ç”¨ä¼˜å…ˆçº§æœ€é«˜çš„"${winningRule.groupName}"`;
                        }
                    }

                    result.conflicts.push({
                        itemName: item.name,
                        description: description,
                        matchingRules: matchingRules.map(r => r.groupName)
                    });
                }
            }
        });

        return result;
    };

    // Calculate new rule priority based on priority config
    const calculateNewRulePriority = () => {
        const existingRules = groupRules.filter(r => !r.isSystemRule && r.id !== editingRuleId);

        switch (priorityConfig.type) {
            case 'highest':
                return 1;
            case 'after':
                if (priorityConfig.afterRuleId) {
                    const afterRule = existingRules.find(r => r.id === priorityConfig.afterRuleId);
                    return afterRule ? afterRule.priority + 1 : existingRules.length + 1;
                }
                return existingRules.length + 1;
            case 'lowest':
            default:
                return existingRules.length + 1;
        }
    };

    // Insert rule at correct priority position
    const insertRuleAtPriority = (rulesList, newRule) => {
        const targetPriority = newRule.priority;

        // Adjust priorities of existing rules
        rulesList.forEach(rule => {
            if (rule.priority >= targetPriority) {
                rule.priority += 1;
            }
        });

        // Add new rule
        rulesList.push(newRule);
    };

    // Insert new rule with priority and adjust other rules
    const insertNewRuleWithPriority = (newRule) => {
        const targetPriority = newRule.priority;

        // Adjust priorities of existing rules that should come after the new rule
        groupRules.forEach(rule => {
            if (!rule.isSystemRule && rule.priority >= targetPriority) {
                rule.priority += 1;
            }
        });

        // Add the new rule
        groupRules.push(newRule);

        // Sort rules by priority to maintain order
        groupRules.sort((a, b) => a.priority - b.priority);

        // Ensure priorities are consecutive
        const userRules = groupRules.filter(r => !r.isSystemRule);
        userRules.forEach((rule, index) => {
            rule.priority = index + 1;
        });
    };

    // Test rules button
    btnTestRules.addEventListener('click', () => {
        alert('è§„åˆ™æµ‹è¯•åŠŸèƒ½å¼€å‘ä¸­...');
    });

    // --- 6. è§„åˆ™æ‹–æ‹½æ’åºåŠŸèƒ½ ---

    // å°†æ‹–æ‹½å˜é‡è®¾ç½®ä¸ºå…¨å±€å˜é‡ä»¥ä¾¿è°ƒè¯•
    window.draggedRuleElement = null;
    window.draggedRuleId = null;
    window.draggedRuleIndex = -1;

    // åˆå§‹åŒ–æ‹–æ‹½åŠŸèƒ½
    const initRuleDragAndDrop = () => {
        console.log('åˆå§‹åŒ–æ‹–æ‹½åŠŸèƒ½');
        const ruleTableBody = document.getElementById('rule-table-body');

        // ä½¿ç”¨äº‹ä»¶å§”æ‰˜å¤„ç†æ‹–æ‹½äº‹ä»¶
        ruleTableBody.addEventListener('dragstart', handleDragStart);
        ruleTableBody.addEventListener('dragover', handleDragOver);
        ruleTableBody.addEventListener('dragenter', handleDragEnter);
        ruleTableBody.addEventListener('dragleave', handleDragLeave);
        ruleTableBody.addEventListener('drop', handleDrop);
        ruleTableBody.addEventListener('dragend', handleDragEnd);
    };

    const handleDragStart = (e) => {
        // åªæœ‰æ‹–æ‹½æ‰‹æŸ„æ‰èƒ½è§¦å‘æ‹–æ‹½
        if (!e.target.classList.contains('rule-drag-handle')) {
            e.preventDefault();
            return;
        }

        const ruleRow = e.target.closest('.table-row');
        if (!ruleRow) return;

        window.draggedRuleElement = ruleRow;
        window.draggedRuleId = ruleRow.dataset.ruleId;
        window.draggedRuleIndex = Array.from(ruleRow.parentNode.children).indexOf(ruleRow);

        // è®¾ç½®æ‹–æ‹½æ ·å¼
        ruleRow.classList.add('dragging');

        // è®¾ç½®æ‹–æ‹½æ•°æ®
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', ruleRow.outerHTML);

        // è®¾ç½®æ‹–æ‹½å›¾åƒï¼ˆå¯é€‰ï¼‰
        const dragImage = ruleRow.cloneNode(true);
        dragImage.style.opacity = '0.8';
        dragImage.style.transform = 'rotate(2deg)';
        document.body.appendChild(dragImage);
        e.dataTransfer.setDragImage(dragImage, 0, 0);
        setTimeout(() => document.body.removeChild(dragImage), 0);
    };

    const handleDragOver = (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
    };

    const handleDragEnter = (e) => {
        e.preventDefault();
        const ruleRow = e.target.closest('.table-row');
        if (!ruleRow || ruleRow === window.draggedRuleElement) return;

        // æ¸…é™¤å…¶ä»–è¡Œçš„æ‹–æ‹½æ ·å¼
        document.querySelectorAll('.table-row.drag-over, .table-row.drag-over-bottom').forEach(row => {
            row.classList.remove('drag-over', 'drag-over-bottom');
        });

        // ç¡®å®šæ’å…¥ä½ç½®
        const rect = ruleRow.getBoundingClientRect();
        const midY = rect.top + rect.height / 2;
        const mouseY = e.clientY;

        if (mouseY < midY) {
            ruleRow.classList.add('drag-over');
        } else {
            ruleRow.classList.add('drag-over-bottom');
        }
    };

    const handleDragLeave = (e) => {
        const ruleRow = e.target.closest('.table-row');
        if (!ruleRow) return;

        // æ£€æŸ¥é¼ æ ‡æ˜¯å¦çœŸçš„ç¦»å¼€äº†å…ƒç´ 
        const rect = ruleRow.getBoundingClientRect();
        const x = e.clientX;
        const y = e.clientY;

        if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
            ruleRow.classList.remove('drag-over', 'drag-over-bottom');
        }
    };

    const handleDrop = (e) => {
        e.preventDefault();

        const targetRow = e.target.closest('.table-row');
        if (!targetRow || targetRow === window.draggedRuleElement) return;

        const targetRuleId = targetRow.dataset.ruleId;
        const targetIndex = Array.from(targetRow.parentNode.children).indexOf(targetRow);

        // ç¡®å®šæ’å…¥ä½ç½®
        const rect = targetRow.getBoundingClientRect();
        const midY = rect.top + rect.height / 2;
        const mouseY = e.clientY;
        const insertBefore = mouseY < midY;

        // è®¡ç®—æ–°çš„ä¼˜å…ˆçº§
        let newPriority;
        if (insertBefore) {
            newPriority = targetIndex + 1;
        } else {
            newPriority = targetIndex + 2;
        }

        // æ›´æ–°è§„åˆ™ä¼˜å…ˆçº§
        updateRulePriority(window.draggedRuleId, newPriority);

        // æ¸…é™¤æ‹–æ‹½æ ·å¼
        clearDragStyles();

        // æ˜¾ç¤ºæˆåŠŸåé¦ˆ
        showDragSuccessFeedback(window.draggedRuleElement);
    };

    const handleDragEnd = (e) => {
        clearDragStyles();
        window.draggedRuleElement = null;
        window.draggedRuleId = null;
        window.draggedRuleIndex = -1;
    };

    const clearDragStyles = () => {
        document.querySelectorAll('.table-row.dragging, .table-row.drag-over, .table-row.drag-over-bottom').forEach(row => {
            row.classList.remove('dragging', 'drag-over', 'drag-over-bottom');
        });
    };

    const updateRulePriority = (ruleId, newPriority) => {
        const draggedRule = groupRules.find(rule => rule.id === ruleId);
        if (!draggedRule) return;

        const oldPriority = draggedRule.priority;

        // é‡æ–°æ’åºæ‰€æœ‰è§„åˆ™çš„ä¼˜å…ˆçº§
        if (newPriority > oldPriority) {
            // å‘ä¸‹ç§»åŠ¨ï¼šå°†ä¸­é—´çš„è§„åˆ™ä¼˜å…ˆçº§å‡1
            groupRules.forEach(rule => {
                if (rule.priority > oldPriority && rule.priority < newPriority) {
                    rule.priority--;
                }
            });
            draggedRule.priority = newPriority - 1;
        } else {
            // å‘ä¸Šç§»åŠ¨ï¼šå°†ä¸­é—´çš„è§„åˆ™ä¼˜å…ˆçº§åŠ 1
            groupRules.forEach(rule => {
                if (rule.priority >= newPriority && rule.priority < oldPriority) {
                    rule.priority++;
                }
            });
            draggedRule.priority = newPriority;
        }

        // é‡æ–°æ’åºè§„åˆ™æ•°ç»„
        groupRules.sort((a, b) => a.priority - b.priority);

        // ç¡®ä¿ä¼˜å…ˆçº§è¿ç»­
        groupRules.forEach((rule, index) => {
            rule.priority = index + 1;
        });

        // ä¿å­˜åˆ°localStorage
        saveRulesToStorage();

        // é‡æ–°åº”ç”¨è§„åˆ™
        applyRules();

        // é‡æ–°æ¸²æŸ“è§„åˆ™åˆ—è¡¨
        renderRuleListInPanel();
    };

    const showDragSuccessFeedback = (ruleElement) => {
        if (!ruleElement) return;

        // æ·»åŠ æˆåŠŸåé¦ˆæ ·å¼
        ruleElement.style.backgroundColor = '#f6ffed';
        ruleElement.style.border = '1px solid #b7eb8f';
        ruleElement.style.transition = 'all 0.3s ease';

        // 2ç§’åç§»é™¤åé¦ˆæ ·å¼
        setTimeout(() => {
            ruleElement.style.backgroundColor = '';
            ruleElement.style.border = '';
            setTimeout(() => {
                ruleElement.style.transition = '';
            }, 300);
        }, 2000);
    };

    // --- 7. ä¼˜å…ˆçº§è°ƒæ•´æŒ‰é’®åŠŸèƒ½ ---

    // ä¼˜å…ˆçº§è°ƒæ•´äº‹ä»¶å¤„ç†
    document.addEventListener('click', (e) => {
        if (e.target.classList.contains('priority-top')) {
            const ruleId = e.target.dataset.ruleId;
            const rule = groupRules.find(r => r.id === ruleId);
            if (rule && rule.isSystemRule) {
                alert('ç³»ç»Ÿè§„åˆ™ä¸èƒ½è°ƒæ•´ä¼˜å…ˆçº§');
                return;
            }
            adjustRulePriority(ruleId, 'top');
        } else if (e.target.classList.contains('priority-up')) {
            const ruleId = e.target.dataset.ruleId;
            const rule = groupRules.find(r => r.id === ruleId);
            if (rule && rule.isSystemRule) {
                alert('ç³»ç»Ÿè§„åˆ™ä¸èƒ½è°ƒæ•´ä¼˜å…ˆçº§');
                return;
            }
            adjustRulePriority(ruleId, 'up');
        } else if (e.target.classList.contains('priority-down')) {
            const ruleId = e.target.dataset.ruleId;
            const rule = groupRules.find(r => r.id === ruleId);
            if (rule && rule.isSystemRule) {
                alert('ç³»ç»Ÿè§„åˆ™ä¸èƒ½è°ƒæ•´ä¼˜å…ˆçº§');
                return;
            }
            adjustRulePriority(ruleId, 'down');
        } else if (e.target.classList.contains('priority-bottom')) {
            const ruleId = e.target.dataset.ruleId;
            const rule = groupRules.find(r => r.id === ruleId);
            if (rule && rule.isSystemRule) {
                alert('ç³»ç»Ÿè§„åˆ™ä¸èƒ½è°ƒæ•´ä¼˜å…ˆçº§');
                return;
            }
            adjustRulePriority(ruleId, 'bottom');
        }
    });

    // ä¼˜å…ˆçº§è°ƒæ•´å‡½æ•°
    const adjustRulePriority = (ruleId, action) => {
        const rule = groupRules.find(r => r.id === ruleId);
        if (!rule) return;

        const currentPriority = rule.priority;
        const maxPriority = groupRules.length;
        let newPriority;

        switch (action) {
            case 'top':
                if (currentPriority === 1) return; // å·²ç»æ˜¯ç¬¬ä¸€ä½
                newPriority = 1;
                break;
            case 'up':
                if (currentPriority === 1) return; // å·²ç»æ˜¯ç¬¬ä¸€ä½
                newPriority = currentPriority - 1;
                break;
            case 'down':
                if (currentPriority === maxPriority) return; // å·²ç»æ˜¯æœ€åä¸€ä½
                newPriority = currentPriority + 1;
                break;
            case 'bottom':
                if (currentPriority === maxPriority) return; // å·²ç»æ˜¯æœ€åä¸€ä½
                newPriority = maxPriority;
                break;
            default:
                return;
        }

        // æ›´æ–°ä¼˜å…ˆçº§
        updateRulePriorityByAction(ruleId, newPriority, action);

        // æ˜¾ç¤ºæˆåŠŸåé¦ˆ
        setTimeout(() => {
            const updatedRuleRow = document.querySelector(`[data-rule-id="${ruleId}"]`);
            if (updatedRuleRow) {
                showPriorityAdjustmentFeedback(updatedRuleRow, action);
            }
        }, 100);
    };

    // æ ¹æ®æ“ä½œç±»å‹æ›´æ–°è§„åˆ™ä¼˜å…ˆçº§
    const updateRulePriorityByAction = (ruleId, newPriority, action) => {
        const rule = groupRules.find(r => r.id === ruleId);
        if (!rule) return;

        const oldPriority = rule.priority;

        if (action === 'top') {
            // ç½®é¡¶ï¼šå°†ç›®æ ‡è§„åˆ™è®¾ä¸º1ï¼Œå…¶ä»–è§„åˆ™ä¼˜å…ˆçº§+1
            groupRules.forEach(r => {
                if (r.id === ruleId) {
                    r.priority = 1;
                } else if (r.priority < oldPriority) {
                    r.priority += 1;
                }
            });
        } else if (action === 'bottom') {
            // ç½®åº•ï¼šå°†ç›®æ ‡è§„åˆ™è®¾ä¸ºæœ€å¤§å€¼ï¼Œå…¶ä»–è§„åˆ™ä¼˜å…ˆçº§-1
            const maxPriority = groupRules.length;
            groupRules.forEach(r => {
                if (r.id === ruleId) {
                    r.priority = maxPriority;
                } else if (r.priority > oldPriority) {
                    r.priority -= 1;
                }
            });
        } else if (action === 'up') {
            // ä¸Šç§»ï¼šä¸ä¸Šä¸€ä¸ªè§„åˆ™äº¤æ¢ä¼˜å…ˆçº§
            const targetRule = groupRules.find(r => r.priority === oldPriority - 1);
            if (targetRule) {
                targetRule.priority = oldPriority;
                rule.priority = oldPriority - 1;
            }
        } else if (action === 'down') {
            // ä¸‹ç§»ï¼šä¸ä¸‹ä¸€ä¸ªè§„åˆ™äº¤æ¢ä¼˜å…ˆçº§
            const targetRule = groupRules.find(r => r.priority === oldPriority + 1);
            if (targetRule) {
                targetRule.priority = oldPriority;
                rule.priority = oldPriority + 1;
            }
        }

        // é‡æ–°æ’åºè§„åˆ™æ•°ç»„
        groupRules.sort((a, b) => a.priority - b.priority);

        // ç¡®ä¿ä¼˜å…ˆçº§è¿ç»­
        groupRules.forEach((rule, index) => {
            rule.priority = index + 1;
        });

        // ä¿å­˜åˆ°localStorage
        saveRulesToStorage();

        // é‡æ–°åº”ç”¨è§„åˆ™
        applyRules();

        // é‡æ–°æ¸²æŸ“è§„åˆ™åˆ—è¡¨
        renderRuleListInPanel();
    };

    // æ˜¾ç¤ºä¼˜å…ˆçº§è°ƒæ•´æˆåŠŸåé¦ˆ
    const showPriorityAdjustmentFeedback = (ruleElement, action) => {
        if (!ruleElement) return;

        const actionText = {
            'top': 'å·²ç½®é¡¶',
            'up': 'å·²ä¸Šç§»',
            'down': 'å·²ä¸‹ç§»',
            'bottom': 'å·²ç½®åº•'
        };

        // æ·»åŠ æˆåŠŸåé¦ˆæ ·å¼
        ruleElement.style.backgroundColor = '#f6ffed';
        ruleElement.style.border = '1px solid #b7eb8f';
        ruleElement.style.transition = 'all 0.3s ease';

        // æ˜¾ç¤ºæ“ä½œæç¤ºï¼ˆå¯é€‰ï¼‰
        console.log(`è§„åˆ™ ${ruleElement.dataset.ruleId} ${actionText[action]}`);

        // 2ç§’åç§»é™¤åé¦ˆæ ·å¼
        setTimeout(() => {
            ruleElement.style.backgroundColor = '';
            ruleElement.style.border = '';
            setTimeout(() => {
                ruleElement.style.transition = '';
            }, 300);
        }, 2000);
    };

    // --- 8. è§„åˆ™å¤šé€‰åŠŸèƒ½ ---
    
    // æ›´æ–°å…¨é€‰å¤é€‰æ¡†çŠ¶æ€
    const updateSelectAllRulesCheckbox = () => {
        const checkboxes = ruleTableBody.querySelectorAll('.rule-checkbox');

        if (checkboxes.length === 0) {
            selectAllRulesCheckbox.checked = false;
            selectAllRulesCheckbox.disabled = true;
        } else {
            selectAllRulesCheckbox.disabled = false;
            selectAllRulesCheckbox.checked = Array.from(checkboxes).every(cb => cb.checked);
        }

        // æ›´æ–°æ‰¹é‡æ“ä½œæŒ‰é’®çŠ¶æ€
        updateBatchButtonsState();
    };
    
    // æ›´æ–°æ‰¹é‡æ“ä½œæŒ‰é’®çŠ¶æ€
    const updateBatchButtonsState = () => {
        const checkboxes = document.querySelectorAll('.rule-checkbox:checked');
        const batchDeleteBtn = document.getElementById('btn-batch-delete');
        const batchToggleBtn = document.getElementById('btn-batch-toggle');
        
        const hasSelected = checkboxes.length > 0;
        batchDeleteBtn.disabled = !hasSelected;
        batchToggleBtn.disabled = !hasSelected;
    };
    
    // å…¨é€‰å¤é€‰æ¡†äº‹ä»¶å¤„ç†
    document.getElementById('select-all-rules').addEventListener('change', (e) => {
        const isChecked = e.target.checked;
        document.querySelectorAll('.rule-checkbox').forEach(cb => {
            cb.checked = isChecked;
        });
        updateBatchButtonsState();
    });
    
    // è§„åˆ™åˆ—è¡¨å®¹å™¨çš„äº‹ä»¶å§”æ‰˜ï¼Œå¤„ç†è§„åˆ™å¤é€‰æ¡†çš„å˜åŒ–
    ruleListContainer.addEventListener('change', (e) => {
        if (e.target.classList.contains('rule-checkbox')) {
            // æ›´æ–°è§„åˆ™çš„å¯ç”¨çŠ¶æ€
            const ruleId = e.target.dataset.ruleId;
            const rule = groupRules.find(r => r.id === ruleId);
            if (rule) {
                rule.enabled = e.target.checked;
                // ä¿å­˜åˆ°localStorageï¼ˆæ’é™¤ç³»ç»Ÿè§„åˆ™ï¼‰
                saveRulesToStorage();
                // é‡æ–°åº”ç”¨è§„åˆ™
                applyRules();
            }
            updateSelectAllRulesCheckbox();
        }
    });
    
    // æ‰¹é‡åˆ é™¤æŒ‰é’®äº‹ä»¶å¤„ç†
    document.getElementById('btn-batch-delete').addEventListener('click', () => {
        const selectedCheckboxes = document.querySelectorAll('.rule-checkbox:checked');
        if (selectedCheckboxes.length === 0) return;

        const selectedIds = Array.from(selectedCheckboxes).map(cb => cb.dataset.ruleId);

        // æ£€æŸ¥æ˜¯å¦åŒ…å«ç³»ç»Ÿè§„åˆ™
        const selectedRules = groupRules.filter(rule => selectedIds.includes(rule.id));
        const hasSystemRule = selectedRules.some(rule => rule.isSystemRule);

        if (hasSystemRule) {
            alert('ä¸èƒ½åˆ é™¤ç³»ç»Ÿè§„åˆ™ï¼Œè¯·å–æ¶ˆé€‰æ‹©ç³»ç»Ÿè§„åˆ™åé‡è¯•');
            return;
        }
        
        if (confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedIds.length} æ¡è§„åˆ™å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`)) {
            // ä»è§„åˆ™æ•°ç»„ä¸­åˆ é™¤é€‰ä¸­çš„è§„åˆ™
            groupRules = groupRules.filter(rule => !selectedIds.includes(rule.id));
            
            // é‡æ–°æ’åºä¼˜å…ˆçº§
            groupRules.forEach((rule, index) => {
                rule.priority = index + 1;
            });
            
            // ä¿å­˜åˆ°localStorage
            localStorage.setItem('groupRules', JSON.stringify(groupRules));
            
            // é‡æ–°åº”ç”¨è§„åˆ™
            applyRules();
            
            // æ›´æ–°UI
            renderRuleListInPanel();
            updateSelectAllRulesCheckbox();
        }
    });
    
    // æ‰¹é‡å¯ç”¨/æš‚åœæŒ‰é’®äº‹ä»¶å¤„ç†
    document.getElementById('btn-batch-toggle').addEventListener('click', () => {
        const selectedCheckboxes = document.querySelectorAll('.rule-checkbox:checked');
        if (selectedCheckboxes.length === 0) return;
        
        const selectedIds = Array.from(selectedCheckboxes).map(cb => cb.dataset.ruleId);
        
        // ç¡®å®šæ“ä½œç±»å‹ï¼ˆå¯ç”¨æˆ–æš‚åœï¼‰
        // å¦‚æœæ‰€æœ‰é€‰ä¸­çš„è§„åˆ™éƒ½æ˜¯å¯ç”¨çŠ¶æ€ï¼Œåˆ™æ‰§è¡Œæš‚åœæ“ä½œ
        // å¦‚æœæœ‰ä»»ä½•ä¸€ä¸ªè§„åˆ™æ˜¯æš‚åœçŠ¶æ€ï¼Œåˆ™æ‰§è¡Œå¯ç”¨æ“ä½œ
        const selectedRules = groupRules.filter(rule => selectedIds.includes(rule.id));
        const allEnabled = selectedRules.every(rule => rule.enabled);
        const newState = !allEnabled;
        const actionText = newState ? 'å¯ç”¨' : 'æš‚åœ';
        
        if (confirm(`ç¡®å®šè¦${actionText}é€‰ä¸­çš„ ${selectedIds.length} æ¡è§„åˆ™å—ï¼Ÿ`)) {
            // æ›´æ–°è§„åˆ™çŠ¶æ€
            selectedRules.forEach(rule => {
                rule.enabled = newState;
            });
            
            // ä¿å­˜åˆ°localStorage
            saveRulesToStorage();
            
            // é‡æ–°åº”ç”¨è§„åˆ™
            applyRules();
            
            // æ›´æ–°UI
            renderRuleListInPanel();
        }
    });

    // --- 8. IMPORT/EXPORT FUNCTIONALITY ---

    // å¯¼å‡ºè§„åˆ™åŠŸèƒ½
    const exportRules = () => {
        try {
            // å‡†å¤‡å¯¼å‡ºæ•°æ®
            const exportData = {
                version: "1.0",
                exportTime: new Date().toISOString(),
                rules: groupRules.filter(rule => !rule.isSystemRule).map(rule => ({
                    id: rule.id,
                    groupName: rule.groupName,
                    rule: rule.rule,
                    priority: rule.priority,
                    enabled: rule.enabled,
                    bindingType: rule.bindingType,
                    createTime: rule.createTime || new Date().toISOString()
                }))
            };

            // ç”Ÿæˆæ–‡ä»¶å
            const now = new Date();
            const timestamp = now.getFullYear() +
                            String(now.getMonth() + 1).padStart(2, '0') +
                            String(now.getDate()).padStart(2, '0') + '_' +
                            String(now.getHours()).padStart(2, '0') +
                            String(now.getMinutes()).padStart(2, '0') +
                            String(now.getSeconds()).padStart(2, '0');
            const filename = `grouping_rules_${timestamp}.json`;

            // åˆ›å»ºä¸‹è½½é“¾æ¥
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);

            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            // æ˜¾ç¤ºæˆåŠŸæç¤º
            showNotification(`æˆåŠŸå¯¼å‡º ${exportData.rules.length} æ¡è§„åˆ™åˆ°æ–‡ä»¶ ${filename}`, 'success');

        } catch (error) {
            console.error('Export failed:', error);
            showNotification('å¯¼å‡ºå¤±è´¥ï¼š' + error.message, 'error');
        }
    };

    // å¯¼å…¥è§„åˆ™åŠŸèƒ½
    const importRules = (file) => {
        const reader = new FileReader();

        reader.onload = (e) => {
            try {
                const importData = JSON.parse(e.target.result);

                // éªŒè¯æ–‡ä»¶æ ¼å¼
                if (!importData.rules || !Array.isArray(importData.rules)) {
                    throw new Error('æ— æ•ˆçš„æ–‡ä»¶æ ¼å¼ï¼šç¼ºå°‘è§„åˆ™æ•°æ®');
                }

                // éªŒè¯è§„åˆ™æ•°æ®ç»“æ„
                const validRules = [];
                const errors = [];

                importData.rules.forEach((rule, index) => {
                    try {
                        // éªŒè¯å¿…éœ€å­—æ®µ
                        if (!rule.groupName || !rule.rule) {
                            throw new Error(`è§„åˆ™ ${index + 1}ï¼šç¼ºå°‘å¿…éœ€å­—æ®µ`);
                        }

                        // éªŒè¯è§„åˆ™ç±»å‹
                        if (!rule.rule.type || !['keywords', 'wildcard', 'regex'].includes(rule.rule.type)) {
                            throw new Error(`è§„åˆ™ ${index + 1}ï¼šæ— æ•ˆçš„åŒ¹é…ç±»å‹`);
                        }

                        // ç”Ÿæˆæ–°çš„å”¯ä¸€IDä»¥é¿å…å†²çª
                        const newId = 'imported_rule_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

                        // åˆ›å»ºè§„åˆ™å¯¹è±¡
                        const newRule = {
                            id: newId,
                            groupName: rule.groupName,
                            rule: rule.rule,
                            priority: 0, // ä¸´æ—¶è®¾ç½®ï¼Œç¨åé‡æ–°è®¡ç®—
                            enabled: rule.enabled !== false, // é»˜è®¤å¯ç”¨
                            bindingType: rule.bindingType || 'existing',
                            createTime: new Date().toISOString(),
                            stats: {
                                matchCount: 0,
                                lastMatched: null,
                                conflictCount: 0
                            }
                        };

                        validRules.push(newRule);

                    } catch (ruleError) {
                        errors.push(ruleError.message);
                    }
                });

                if (validRules.length === 0) {
                    throw new Error('æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„è§„åˆ™æ•°æ®');
                }

                // è®¡ç®—æ–°è§„åˆ™çš„ä¼˜å…ˆçº§
                const maxPriority = Math.max(...groupRules.filter(r => !r.isSystemRule).map(r => r.priority), 0);
                validRules.forEach((rule, index) => {
                    rule.priority = maxPriority + index + 1;
                });

                // æ·»åŠ è§„åˆ™åˆ°ç°æœ‰è§„åˆ™åˆ—è¡¨
                groupRules.push(...validRules);

                // ä¿å­˜åˆ°localStorage
                saveRulesToStorage();

                // é‡æ–°åº”ç”¨è§„åˆ™
                applyRules();

                // æ›´æ–°UI
                renderRuleListInPanel();

                // æ˜¾ç¤ºæˆåŠŸæç¤º
                let message = `æˆåŠŸå¯¼å…¥ ${validRules.length} æ¡è§„åˆ™`;
                if (errors.length > 0) {
                    message += `ï¼Œè·³è¿‡ ${errors.length} æ¡æ— æ•ˆè§„åˆ™`;
                }
                showNotification(message, 'success');

                // å¦‚æœæœ‰é”™è¯¯ï¼Œåœ¨æ§åˆ¶å°æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
                if (errors.length > 0) {
                    console.warn('Import errors:', errors);
                }

            } catch (error) {
                console.error('Import failed:', error);
                showNotification('å¯¼å…¥å¤±è´¥ï¼š' + error.message, 'error');
            }
        };

        reader.onerror = () => {
            showNotification('æ–‡ä»¶è¯»å–å¤±è´¥', 'error');
        };

        reader.readAsText(file);
    };

    // æ˜¾ç¤ºé€šçŸ¥æ¶ˆæ¯çš„è¾…åŠ©å‡½æ•°
    const showNotification = (message, type = 'info') => {
        // åˆ›å»ºé€šçŸ¥å…ƒç´ 
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.textContent = message;

        // æ·»åŠ æ ·å¼
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 4px;
            color: white;
            font-size: 14px;
            z-index: 10000;
            max-width: 400px;
            word-wrap: break-word;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        `;

        // æ ¹æ®ç±»å‹è®¾ç½®èƒŒæ™¯è‰²
        switch (type) {
            case 'success':
                notification.style.backgroundColor = '#52c41a';
                break;
            case 'error':
                notification.style.backgroundColor = '#ff4d4f';
                break;
            case 'warning':
                notification.style.backgroundColor = '#faad14';
                break;
            default:
                notification.style.backgroundColor = '#1890ff';
        }

        // æ·»åŠ åˆ°é¡µé¢
        document.body.appendChild(notification);

        // 3ç§’åè‡ªåŠ¨ç§»é™¤
        setTimeout(() => {
            notification.style.opacity = '0';
            notification.style.transform = 'translateX(100%)';
            setTimeout(() => {
                if (notification.parentNode) {
                    document.body.removeChild(notification);
                }
            }, 300);
        }, 3000);
    };

    // å¯¼å‡ºæŒ‰é’®äº‹ä»¶å¤„ç†
    btnExportRules.addEventListener('click', () => {
        const nonSystemRules = groupRules.filter(rule => !rule.isSystemRule);
        if (nonSystemRules.length === 0) {
            showNotification('æ²¡æœ‰å¯å¯¼å‡ºçš„è§„åˆ™', 'warning');
            return;
        }

        exportRules();
    });

    // å¯¼å…¥æŒ‰é’®äº‹ä»¶å¤„ç†
    btnImportRules.addEventListener('click', () => {
        importFileInput.click();
    });

    // æ–‡ä»¶é€‰æ‹©äº‹ä»¶å¤„ç†
    importFileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            if (file.type !== 'application/json' && !file.name.endsWith('.json')) {
                showNotification('è¯·é€‰æ‹©JSONæ ¼å¼çš„æ–‡ä»¶', 'error');
                return;
            }

            if (file.size > 5 * 1024 * 1024) { // 5MBé™åˆ¶
                showNotification('æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡5MB', 'error');
                return;
            }

            importRules(file);
        }

        // æ¸…ç©ºæ–‡ä»¶è¾“å…¥ï¼Œå…è®¸é‡å¤é€‰æ‹©åŒä¸€æ–‡ä»¶
        e.target.value = '';
    });

    // --- 9. INITIAL RENDER ---
    renderAll();

    // åˆå§‹åŒ–æ‹–æ‹½åŠŸèƒ½
    initRuleDragAndDrop();

    // Load rules from localStorage if available
    const savedRules = localStorage.getItem('groupRules');
    if (savedRules) {
        try {
            const loadedRules = JSON.parse(savedRules);
            // ç¡®ä¿æ¯ä¸ªè§„åˆ™éƒ½æœ‰å®Œæ•´çš„æ•°æ®ç»“æ„
            groupRules = loadedRules.map(rule => {
                // ç¡®ä¿è§„åˆ™æœ‰statså¯¹è±¡
                if (!rule.stats) {
                    rule.stats = {
                        matchCount: 0,
                        lastMatched: null,
                        conflictCount: 0
                    };
                }
                return rule;
            });
            // ç¡®ä¿ç³»ç»Ÿè§„åˆ™å­˜åœ¨
            ensureSystemRule();
            applyRules();
        } catch (e) {
            console.error('Failed to load rules:', e);
            // å¦‚æœåŠ è½½å¤±è´¥ï¼Œç¡®ä¿ç³»ç»Ÿè§„åˆ™å­˜åœ¨
            ensureSystemRule();
        }
    } else {
        // æ·»åŠ ä¸€äº›ç¤ºä¾‹è§„åˆ™ç”¨äºæµ‹è¯•æ‹–æ‹½åŠŸèƒ½
        groupRules = [
            createRule({
                id: 'rule_1',
                name: 'å¤´æ¡è§„åˆ™',
                groupName: 'å¤´æ¡ç³»',
                bindingType: 'create',
                priority: 1,
                enabled: true,
                matchMode: 'wildcard',
                rule: { type: 'wildcard', pattern: 'å¤´æ¡*' }
            }),
            createRule({
                id: 'rule_2',
                name: 'æŠ–éŸ³è§„åˆ™',
                groupName: 'æŠ–éŸ³ç³»',
                bindingType: 'create',
                priority: 2,
                enabled: true,
                matchMode: 'wildcard',
                rule: { type: 'wildcard', pattern: 'æŠ–éŸ³*' }
            }),
            createRule({
                id: 'rule_3',
                name: 'ç§»åŠ¨ç«¯è§„åˆ™',
                groupName: 'ç§»åŠ¨ç«¯',
                bindingType: 'existing',
                priority: 3,
                enabled: true,
                matchMode: 'keywords',
                rule: {
                    type: 'keywords',
                    includeKeywords: ['ios', 'android'],
                    excludeKeywords: []
                }
            }),
            createRule({
                id: 'rule_4',
                name: 'PCç«¯è§„åˆ™',
                groupName: 'PCç«¯',
                bindingType: 'existing',
                priority: 4,
                enabled: false,
                matchMode: 'keywords',
                rule: {
                    type: 'keywords',
                    includeKeywords: ['windows', 'macos'],
                    excludeKeywords: []
                }
            })
        ];
        // ç¡®ä¿ç³»ç»Ÿè§„åˆ™å­˜åœ¨
        ensureSystemRule();
        applyRules();
    }

    // Save rules to localStorage on change
    window.addEventListener('beforeunload', () => {
        saveRulesToStorage();
    });
});
</script>

</body>
</html>